{"meta":{"title":"今晚打老虎","subtitle":"今晚打老虎","description":"日常学习笔记","author":"杨欣","url":"https://mxzenf123.github.io/index.html","root":"/"},"pages":[{"title":"文章分类","date":"2019-10-05T02:49:22.000Z","updated":"2019-10-05T06:57:11.492Z","comments":true,"path":"categories/index.html","permalink":"https://mxzenf123.github.io/index.html/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-05T05:57:46.000Z","updated":"2019-10-05T06:55:05.558Z","comments":true,"path":"tags/index.html","permalink":"https://mxzenf123.github.io/index.html/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java并发编程基本知识介绍","slug":"并发编程基本知识介绍","date":"2021-04-05T07:48:28.463Z","updated":"2021-04-05T08:50:43.532Z","comments":true,"path":"2021/04/05/并发编程基本知识介绍/","link":"","permalink":"https://mxzenf123.github.io/index.html/2021/04/05/并发编程基本知识介绍/","excerpt":"","text":"什么是并发？大佬的话作为开篇：两个词很好的说明了并发和并行的区别：Parallel Computing：并行计算Concurrent programming：并发编程例如你打开浏览器，输入你最爱的P站，拿着薯片看两个人打架的视频，同时你还不忘打开QQ看群里大佬们各种吹水，这就是并发。CPU单核与多核早期的dos操作系统只支持单个任务的执行，在同一个时刻只有一个进程运行直到该任务执行完成才能执行下一个任务。这个时期的操作系统都只有一个CPU，但这并不是机器的限制，而是操作系统的限制。之后随着操作系统进化，逐渐开始支持多任务执行，比如，unix，linux和windows。这并不是真正意义上的同时执行，而是单个CPU对于每个任务分配了时间片，只要执行的够快就让我们感觉是同时在执行。单核CPU在同一时间始终只能运行一个进程，只有在CPU多核情况下才能实现真正的并行。如果是2核就能够同时执行2个进程，4核就能够同时执行4个进程进程和线程进程：（英语：process），是指计算机中已运行的程序。进程曾经是分时系统的基本运作单位。在面向进程设计的系统（如早期的UNIX，Linux 2.4及更早的版本）中，进程是程序的基本执行实体；在面向线程设计的系统（如当代多数操作系统、Linux 2.6及更新的版本）中，进程本身不是基本运行单位，而是线程的容器。线程：（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。进程是线程的容器，一个进程至少有一个线程。操作系统为进程运行分配所需要的资源例如内存，存储器，文件和IO设备等。线程共享进程分配的资源，同时也会有自己的私有资源。","categories":[{"name":"java基础","slug":"java基础","permalink":"https://mxzenf123.github.io/index.html/categories/java基础/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"https://mxzenf123.github.io/index.html/tags/java并发编程/"}]},{"title":"3分钟学会mybatis代码生成器使用","slug":"3分钟学会mybatis代码生成器使用","date":"2021-03-28T09:11:55.566Z","updated":"2021-03-28T09:27:33.941Z","comments":true,"path":"2021/03/28/3分钟学会mybatis代码生成器使用/","link":"","permalink":"https://mxzenf123.github.io/index.html/2021/03/28/3分钟学会mybatis代码生成器使用/","excerpt":"","text":"使用mybatis多少都会涉及到操作数据库的sql配置xml文件，数据库对象的model和mapper文件，如果数据库表比较多手撸起来还是费劲。使用mybatis提供的工具自动生成我们使用mybatis过程中需要手写的mapper和model文件：maven的插件方式一，引入对mybatis-generator-plugin插件1234567891011121314151617181920&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;!-- 输出详细信息 --&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;!-- 覆盖生成文件 --&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator-configuration.xml&lt;/configurationFile&gt; &lt;/configuration&gt;&lt;/plugin&gt;二，编写配置文件generator-configuration.xml，我的如下：12345678910111213141516171819&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;classPathEntry location=\"数据库驱动包路径\"/&gt; &lt;context id=\"dsql\" targetRuntime=\"MyBatis3DynamicSql\"&gt; &lt;jdbcConnection driverClass=\"数据库驱动包\" connectionURL=\"你的数据库链接信息\" userId=\"数据库用户名\" password=\"数据库密码\" /&gt; &lt;javaModelGenerator targetPackage=\"org.yangxin.demo1.model\" targetProject=\"src/main/java\"/&gt; &lt;javaClientGenerator targetPackage=\"org.yangxin.demo1.mapper\" targetProject=\"src/main/java\"/&gt; &lt;table tableName=\"FM01\" /&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt;配置文件的xml可以参考[mybatis官网)(http://mybatis.org/generator/configreference/xmlconfig.html)。上面的xml主要配置三个信息：需要连接的数据库的驱动包位置以及对应的链接信息生成mapper和model的包名称数据库表三，运行mybatis-generator-plugin插件：mvn mybatis-generator:generate，运行后会生成对应的mapper和model","categories":[{"name":"mybatis","slug":"mybatis","permalink":"https://mxzenf123.github.io/index.html/categories/mybatis/"}],"tags":[{"name":"mybatis代码生成器","slug":"mybatis代码生成器","permalink":"https://mxzenf123.github.io/index.html/tags/mybatis代码生成器/"}]},{"title":"一文精通mybatis拦截器","slug":"一文精通mybatis拦截器","date":"2021-03-14T06:19:06.125Z","updated":"2021-03-14T07:26:27.825Z","comments":true,"path":"2021/03/14/一文精通mybatis拦截器/","link":"","permalink":"https://mxzenf123.github.io/index.html/2021/03/14/一文精通mybatis拦截器/","excerpt":"","text":"mybatis插件介绍引用Mybatis官网：MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)ParameterHandler (getParameterObject, setParameters)ResultSetHandler (handleResultSets, handleOutputParameters)StatementHandler (prepare, parameterize, batch, update, query)这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。 如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。 因为在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis 的核心模块。这些都是更底层的类和方法，所以使用插件的时候要特别当心。来看一组例子，通过对Executor接口拦截对query方法输出执行sql的日志信息LogInteceptor实现，继承Inteceptor接口，实现该接口的三个方法：intecept，plugin和setProperties方法。123456789101112131415161718192021222324@Intercepts(&#123;@Signature(type= Executor.class, method = \"query\", args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)public class LogPlugin implements Interceptor &#123; private final static Logger log = LoggerFactory.getLogger(LogPlugin.class); @Override public Object intercept(Invocation invocation) throws Throwable &#123; Object[] objects = invocation.getArgs(); MappedStatement ms = (MappedStatement)objects[0]; log.debug(\"执行sql -&gt; \" + ms.getBoundSql(null).getSql()); log.debug(\"参数 -&gt; \" + objects[1]); return invocation.proceed(); &#125; @Override public Object plugin(Object target) &#123; return Plugin.wrap(target,this); &#125; @Override public void setProperties(Properties properties) &#123; &#125;&#125;MapperConfig.xml和mapper1.xml配置文件，在config文件中引入自定义的拦截器报名加类型的全路径1234567891011&lt;plugins&gt; &lt;plugin interceptor=\"org.apache.ibatis.plugin.LogPlugin\"&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;mapper namespace=\"org.yangxin.mapper1\"&gt; &lt;select id=\"getBlog\" parameterType=\"int\" resultType=\"map\" &gt; select * from blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;测试代码1234@Testpublic void log_plugin_test()&#123; sqlMapper.openSession().selectList(\"org.yangxin.mapper1.getBlog\", 1);&#125;//执行后console输出DEBUG [main] - Logging initialized using ‘class org.apache.ibatis.logging.slf4j.Slf4jImpl’ adapter.DEBUG [main] - 执行sql -&gt; select * from blog where id = ?DEBUG [main] - 参数 -&gt; 1DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Setting autocommit to false on JDBC Connection [org.apache.derby.impl.jdbc.EmbedConnection@398457879 (XID = 38372), (SESSIONID = 5), (DATABASE = ibderby), (DRDAID = null) ]DEBUG [main] - ==&gt; Preparing: select * from blog where id = ?DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1可以看到加粗部分输入了我们打印的执行sql语句信息源码分析解析xml拦截器123456//1，解析config.xml中的plugins节点pluginElement(root.evalNode(\"plugins\"));//2，将拦截器加入Configuration类configuration.addInterceptor(interceptorInstance);interceptorChain.addInterceptor(interceptor);现在我们通过xml配置的拦截器已经在Mybatis全局配置变量inteceptorChain中了生成拦截对象的代理当我们打开sqlsession的时候，会调用Configuration对象来创建一个具体执行sql的Excecutor类。创建这个类的时候就会生成拦截了Executor接口的代理类12345678910//1，创建Executorfinal Executor executor = configuration.newExecutor(tx, execType);//2，生成代理对象executor = (Executor) interceptorChain.pluginAll(executor);public Object pluginAll(Object target) &#123; for (Interceptor interceptor : interceptors) &#123; target = interceptor.plugin(target);g &#125; return target;&#125;这里最重要的就是mybatis的plugin包下面的Plugin类了，该类有下面两个用途:生成jdk代理并实现了InvocationHandler接口解析实现接口Inteceptor类的注解用于生成代理和拦截对应签名的方法结合源码回过后来再看一下demo发现mybatis拦截器设计很简单和巧妙，也很方便对mybatis各接口功能进行拓展","categories":[{"name":"mybatis","slug":"mybatis","permalink":"https://mxzenf123.github.io/index.html/categories/mybatis/"}],"tags":[{"name":"mybatis拦截器","slug":"mybatis拦截器","permalink":"https://mxzenf123.github.io/index.html/tags/mybatis拦截器/"}]},{"title":"mybatis二级缓存入门到精通","slug":"mybatis二级缓存入门到精通","date":"2021-03-06T08:59:50.514Z","updated":"2021-03-06T10:03:33.072Z","comments":true,"path":"2021/03/06/mybatis二级缓存入门到精通/","link":"","permalink":"https://mxzenf123.github.io/index.html/2021/03/06/mybatis二级缓存入门到精通/","excerpt":"","text":"一级缓存是session级别的，缓存在一个session内部有效，如果要多个session共享缓存就需要开启二级缓存二级缓存是namespace级别的，不同的namespace不能够共享缓存入门demo开启二级缓存配置123&lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;/settings&gt;开启后executor会以代理模式创建，统一由CachingExecutor代理。mapper代理配置12345&lt;cache eviction=\"FIFO\" size=\"1024\" flushInterval=\"6000\" /&gt;&lt;select id=\"getBlog\" parameterType=\"string\" resultType=\"map\" useCache=\"true\"&gt; select * from blog where id = #&#123;id&#125;&lt;/select&gt;现在来测试一下，两个不同的session是否共享了缓存1234567SqlSession sqlSession1 = ssf.openSession();SqlSession sqlSession2 = ssf.openSession();//两个不同的sessionAssert.assertNotEquals(sqlSession1,sqlSession2);sqlSession1.selectOne(\"org.yangxin.mapper1.getBlog\",\"1\");sqlSession1.commit();sqlSession2.selectOne(\"org.yangxin.mapper1.getBlog\",\"1\");日志输出结果:123456789DEBUG [main] - Cache Hit Ratio [org.yangxin.mapper1]: 0.0DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Setting autocommit to false on JDBC Connection [org.apache.derby.impl.jdbc.EmbedConnection@1530446316 (XID = 37309), (SESSIONID = 5), (DATABASE = ibderby), (DRDAID = null) ]DEBUG [main] - ==&gt; Preparing: select * from blog where id = ? DEBUG [main] - ==&gt; Parameters: 1(String)DEBUG [main] - &lt;== Total: 1DEBUG [main] - Cache Hit Ratio [org.yangxin.mapper1]: 0.5Process finished with exit code 0可以发现session2在并没有查询数据库来获取结果，实际就是访问的缓存。我们也可以配置mapperstatment中的select关闭缓存，只需将useCache改为false，默认为true123&lt;select id=\"getBlog\" parameterType=\"string\" resultType=\"map\" useCache=\"false\"&gt; select * from blog where id = #&#123;id&#125;&lt;/select&gt;运行代码查看控制台输出结果12345678910DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Setting autocommit to false on JDBC Connection [org.apache.derby.impl.jdbc.EmbedConnection@1222768327 (XID = 37411), (SESSIONID = 5), (DATABASE = ibderby), (DRDAID = null) ]DEBUG [main] - ==&gt; Preparing: select * from blog where id = ? DEBUG [main] - ==&gt; Parameters: 1(String)DEBUG [main] - &lt;== Total: 1DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Setting autocommit to false on JDBC Connection [org.apache.derby.impl.jdbc.EmbedConnection@220454978 (XID = 37415), (SESSIONID = 7), (DATABASE = ibderby), (DRDAID = null) ]DEBUG [main] - ==&gt; Preparing: select * from blog where id = ? DEBUG [main] - ==&gt; Parameters: 1(String)DEBUG [main] - &lt;== Total: 1关闭缓存后，我们看到控制台日志输出了两次通过Jdbc连接查询数据。遗留问题，update，delete，commit和rollback对二级缓存有什么影响，通过下面的源码分析我相信可以找到答案源码分析mybatis只有配置了cacheEnabled为true的时候才会生效二级缓存，这样所有的executor才能够被CachingExecutor代理123if (cacheEnabled) &#123; executor = new CachingExecutor(executor);&#125;CachingExecutor代理了所有executor方法，因为在执行各种ddl语句的时候会对二级缓存产生影响，其中主要管理二级缓存的类是TransactionalCacheManager12345678910111213141516171819202122232425262728293031323334353637383940public class TransactionalCacheManager &#123; //管理所有实现的Cache private Map&lt;Cache, TransactionalCache&gt; transactionalCaches = new HashMap&lt;Cache, TransactionalCache&gt;(); public void clear(Cache cache) &#123; getTransactionalCache(cache).clear(); &#125; public Object getObject(Cache cache, CacheKey key) &#123; return getTransactionalCache(cache).getObject(key); &#125; public void putObject(Cache cache, CacheKey key, Object value) &#123; getTransactionalCache(cache).putObject(key, value); &#125; //将本地缓存调用Cache的put方法使缓存生效 public void commit() &#123; for (TransactionalCache txCache : transactionalCaches.values()) &#123; txCache.commit(); &#125; &#125; //将所有未提交的缓存清空，将获取的缓存数据从缓存中移除 public void rollback() &#123; for (TransactionalCache txCache : transactionalCaches.values()) &#123; txCache.rollback(); &#125; &#125; private TransactionalCache getTransactionalCache(Cache cache) &#123; TransactionalCache txCache = transactionalCaches.get(cache); if (txCache == null) &#123; txCache = new TransactionalCache(cache); transactionalCaches.put(cache, txCache); &#125; return txCache; &#125;&#125;TransactionalCache又是代理类，将所实现的cache代理。executor执行影响缓存发放的时候都是由这个类去做相应的实现","categories":[{"name":"mybatis","slug":"mybatis","permalink":"https://mxzenf123.github.io/index.html/categories/mybatis/"}],"tags":[{"name":"mybatis缓存","slug":"mybatis缓存","permalink":"https://mxzenf123.github.io/index.html/tags/mybatis缓存/"}]},{"title":"java spi入门及原理分析","slug":"spi入门","date":"2021-01-12T11:14:27.890Z","updated":"2021-03-06T10:36:03.618Z","comments":true,"path":"2021/01/12/spi入门/","link":"","permalink":"https://mxzenf123.github.io/index.html/2021/01/12/spi入门/","excerpt":"","text":"介绍维基百科解释查看wiki。spi全称Service privoder Interface，是java的第三方扩展机制。其中：数据库，jndi，声音服务，文件IO和图片IO都有应用代码demo先从简单的”hello world”开始来直观感受一下spi创建接口和实现该接口123456789101112131415/* * 创建接口 */ public interface IHelloWorld&#123; void say(String name); &#125;/* *实现类 */ public class HelloWorldImpl implements IHelloWorld &#123; @Override public void say(String name) &#123; System.out.println(\"hello,\" + name); &#125; &#125;配置文件在resources文件夹下新建META-INF/service，以接口IHelloWorld类全路径未文件命名:文件内容为实现类HelloWorldImpl的全路径名称测试代码123456789@Test//输出 hello worldpublic void spi_test()&#123; ServiceLoader&lt;IHelloWorld&gt; hs = ServiceLoader.load(IHelloWorld.class,Thread.currentThread().getContextClassLoader()); for (IHelloWorld helloWorld : hs) &#123; helloWorld.say(\"world\"); &#125;&#125;原理查看ServiceLoader源码，其中主要有两个问题需要带着去阅读，解决了基本就明白了原理1，为什么要按照META-INI/service，接口文件名和实现类内容创建文件2，如何加载实现类直接上关键代码123456789/* *PREFIX = \"META-INF/services/\" *这段代码就解释了第一个问题 */String fullName = PREFIX + service.getName();if (loader == null) configs = ClassLoader.getSystemResources(fullName);else configs = loader.getResources(fullName);我在jdk1.8中查看源码，inputstream都实现了AutoCloseable，但是大佬们在解析接口命名的文件的时候没有使用try with resources方式，大佬们也有偷懒的时候啊123456789101112131415try &#123; in = u.openStream(); r = new BufferedReader(new InputStreamReader(in, \"utf-8\")); int lc = 1; while ((lc = parseLine(service, u, r, lc, names)) &gt;= 0);&#125; catch (IOException x) &#123; fail(service, \"Error reading configuration file\", x);&#125; finally &#123; try &#123; if (r != null) r.close(); if (in != null) in.close(); &#125; catch (IOException y) &#123; fail(service, \"Error closing configuration file\", y); &#125;&#125;第二个问题就是大家在熟悉不过的使用Class.forName在加载配置文件中的实现类了12345try &#123; c = Class.forName(cn, false, loader);&#125; catch (ClassNotFoundException x) &#123; fail(service,\"Provider \" + cn + \" not found\");&#125;至此spi就算入门了，查看了一下ojdbc.jar包，验证了确实也是以spi的方式提供的，有兴趣的朋友可以再验证一下文章开头所说的服务提供商是否也是spi实现的","categories":[{"name":"java基础","slug":"java基础","permalink":"https://mxzenf123.github.io/index.html/categories/java基础/"}],"tags":[{"name":"spi","slug":"spi","permalink":"https://mxzenf123.github.io/index.html/tags/spi/"},{"name":"java","slug":"java","permalink":"https://mxzenf123.github.io/index.html/tags/java/"}]},{"title":"mybatis分页原理","slug":"mybatis分页原理","date":"2019-12-21T03:27:39.054Z","updated":"2019-12-21T03:51:50.181Z","comments":true,"path":"2019/12/21/mybatis分页原理/","link":"","permalink":"https://mxzenf123.github.io/index.html/2019/12/21/mybatis分页原理/","excerpt":"","text":"mybatis分页原理在通过session查询数据的时候，根据传入的数据结构RowBounds来进行查询数据库结果集的skip和limit操作达到分页的目的mybatis分页相关代码RowBounds类12345678910111213141516171819202122232425262728public class RowBounds &#123; public static final int NO_ROW_OFFSET = 0;//默认 public static final int NO_ROW_LIMIT = Integer.MAX_VALUE;//默认 public static final RowBounds DEFAULT = new RowBounds();//默认 private int offset; private int limit; public RowBounds() &#123; this.offset = NO_ROW_OFFSET; this.limit = NO_ROW_LIMIT; &#125; public RowBounds(int offset, int limit) &#123; this.offset = offset; this.limit = limit; &#125; public int getOffset() &#123; return offset; &#125; public int getLimit() &#123; return limit; &#125;&#125;可以看出RowBounds类还是比较简单，offset和limit只有这两个成员属性，Mybatis分页主要也是根据这两个属性DefaultSqlSession根据RowBounds类进行分页查询123456789101112131415@Override public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) &#123; return this.selectList(statement, parameter, RowBounds.DEFAULT);&#125;public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123; try &#123; MappedStatement ms = configuration.getMappedStatement(statement); return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error querying database. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125;&#125;如果不传入RowBounds那么使用默认的，offset从0开始，limit为Integer最大值DefaultResultSetHandler根据RowBounds进行返回结果集处理12345678910private void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException &#123; DefaultResultContext&lt;Object&gt; resultContext = new DefaultResultContext&lt;Object&gt;(); skipRows(rsw.getResultSet(), rowBounds);//1 while (shouldProcessMoreRows(resultContext, rowBounds)/*2*/ &amp;&amp; rsw.getResultSet().next()) &#123; ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(rsw.getResultSet(), resultMap, null); Object rowValue = getRowValue(rsw, discriminatedResultMap); storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet()); &#125;&#125;1，根据offset跳过结果集到指定行数2，根据limit获取指定数量的结果集总结mybatis自带分页实现较为简单，将所有结果查询出来，然后取固定某段结果。明显的缺点就是需要将结果全部查询出去，如果进行分页需要手动的去计算指定offset和limit，使用不是很方便。","categories":[{"name":"mybatis","slug":"mybatis","permalink":"https://mxzenf123.github.io/index.html/categories/mybatis/"}],"tags":[{"name":"mybatis分页","slug":"mybatis分页","permalink":"https://mxzenf123.github.io/index.html/tags/mybatis分页/"}]},{"title":"mybatis一级缓存源码分析","slug":"mybatis一级缓存","date":"2019-12-14T09:26:53.389Z","updated":"2019-12-14T09:47:53.349Z","comments":true,"path":"2019/12/14/mybatis一级缓存/","link":"","permalink":"https://mxzenf123.github.io/index.html/2019/12/14/mybatis一级缓存/","excerpt":"","text":"源码分析mybatis的一级缓存是session级别默认开启的，如果使用不当不了解其原理会造成一些隐患。session在执行查询的时候委托给executor，一级缓存为起一个map结构的localCache变量实现。主要代码如下12345678//取缓存数据根据cacheKey，cacheKey数据结构感兴趣可以阅读源码list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;if (list != null) &#123; handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);&#125; else &#123; //没取到就查询数据库 list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);&#125;在queryFormDatabase方法中会put操作localCache将结果缓存。但是如果配置了参数localCacheScop为statement级别那么不会进行缓存1234if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123; // 清空localCache clearLocalCache();&#125;常见问题如果对于同一个命名空间select的id相同，不同session可能会存在脏读1234567891011121314//开启两个session//涉及的测试环境在mybatis源码中可以找到SqlSession session1 = sqlMapper.openSession();SqlSession session2 = sqlMapper.openSession();Blog blog1 = session1.selectOne(\"org.apache.ibatis.domain.blog.mappers.NestedBlogMapper.selectBlogJoinedWithPostsAndAuthor\", 1);Blog blog2 = session2.selectOne(\"org.apache.ibatis.domain.blog.mappers.NestedBlogMapper.selectBlogJoinedWithPostsAndAuthor\", 1);assertEquals(\"Jim Business\", blog1.getTitle());assertEquals(\"Jim Business\", blog2.getTitle());session1.update(\"org.apache.ibatis.domain.blog.mappers.NestedBlogMapper.upBlogId\", 1);session1.commit();Blog blog3 = session1.selectOne(\"org.apache.ibatis.domain.blog.mappers.NestedBlogMapper.selectBlogJoinedWithPostsAndAuthor\", 1);Blog blog4 = session2.selectOne(\"org.apache.ibatis.domain.blog.mappers.NestedBlogMapper.selectBlogJoinedWithPostsAndAuthor\", 1);assertEquals(\"new title\", blog4.getTitle());//失败 falseassertEquals(\"new title\", blog3.getTitle());//成功 true上面代码实际上会测试失败，因为产生了脏读。","categories":[{"name":"mybatis","slug":"mybatis","permalink":"https://mxzenf123.github.io/index.html/categories/mybatis/"}],"tags":[{"name":"mybatis缓存","slug":"mybatis缓存","permalink":"https://mxzenf123.github.io/index.html/tags/mybatis缓存/"}]},{"title":"java自动拆装箱问题总结","slug":"java自动拆装箱问题总结","date":"2019-11-03T03:35:43.214Z","updated":"2019-11-03T03:43:41.013Z","comments":true,"path":"2019/11/03/java自动拆装箱问题总结/","link":"","permalink":"https://mxzenf123.github.io/index.html/2019/11/03/java自动拆装箱问题总结/","excerpt":"","text":"java自动拆装箱自jdk1.5以后新增功能。目的是为了解决基础数据类型和对象操作不便利。比如集合List只能操作对象，而无法对基本数据类型进行add，remove等一系列操作。对自动拆装箱学习过程中，产生了一系列疑问，总结如下什么是基础数据类型，什么是包装类jdk如何实现自动拆装箱自动拆装箱优点和缺点自动拆装箱什么时候不自动进行","categories":[{"name":"java基础","slug":"java基础","permalink":"https://mxzenf123.github.io/index.html/categories/java基础/"}],"tags":[{"name":"java自动拆装箱","slug":"java自动拆装箱","permalink":"https://mxzenf123.github.io/index.html/tags/java自动拆装箱/"}]},{"title":"Integer的缓存机制","slug":"Integer自动装箱缓存","date":"2019-11-02T09:03:40.988Z","updated":"2019-11-02T09:10:02.833Z","comments":true,"path":"2019/11/02/Integer自动装箱缓存/","link":"","permalink":"https://mxzenf123.github.io/index.html/2019/11/02/Integer自动装箱缓存/","excerpt":"","text":"123456789101112131415161718192021public class JavaIntegerCache &#123; public static void main(String... strings) &#123; Integer integer1 = 3; Integer integer2 = 3; if (integer1 == integer2) System.out.println(\"integer1 == integer2\"); else System.out.println(\"integer1 != integer2\"); Integer integer3 = 300; Integer integer4 = 300; if (integer3 == integer4) System.out.println(\"integer3 == integer4\"); else System.out.println(\"integer3 != integer4\"); &#125;&#125;由于Integer是对象，两个对象比较，我们普遍的认为上面的两个结果都是false然而结果却会让你大跌眼镜。上面这段代码真正的输出结果：12integer1 == integer2integer3 != integer4原因就在于java5.0以后对于基本类型自动装箱的在范围-127到128之间会进行自动缓存以提升程序性能","categories":[{"name":"java基础","slug":"java基础","permalink":"https://mxzenf123.github.io/index.html/categories/java基础/"}],"tags":[{"name":"java自动装箱","slug":"java自动装箱","permalink":"https://mxzenf123.github.io/index.html/tags/java自动装箱/"},{"name":"java缓存","slug":"java缓存","permalink":"https://mxzenf123.github.io/index.html/tags/java缓存/"}]},{"title":"mybatis动态sql之组合模式","slug":"mybatis动态sql实现之组合模式","date":"2019-11-02T07:19:56.648Z","updated":"2019-11-02T08:33:48.971Z","comments":true,"path":"2019/11/02/mybatis动态sql实现之组合模式/","link":"","permalink":"https://mxzenf123.github.io/index.html/2019/11/02/mybatis动态sql实现之组合模式/","excerpt":"","text":"组合设计模式组合设计模式是一种整体与部分的树形层次关系结构。组合对象中各个对象具有相同的行为模式，这样就能处理简单对象一样处理复杂对象。复杂对象的底层细节将会被屏蔽掉，与客户端解耦，最重要的是和简单对象一样实现了同一个接口mybatis动态sql实现同一个接口1234public interface SqlNode &#123; //共同的行为 boolean apply(DynamicContext context);&#125;复杂对象12345678910111213141516 //混合sqlnode节点，组合不同类型的sqlnode //其他node有：trim,set,where,if,otherwise //choose public class MixedSqlNode implements SqlNode &#123; private final List&lt;SqlNode&gt; contents;public MixedSqlNode(List&lt;SqlNode&gt; contents)&#123; this.contents = contents;&#125;@Overridepublic boolean apply(DynamicContext context)&#123; contents.forEach(node -&gt; node.apply(context)); return true;&#125; &#125;简单对象1234567891011121314151617181920212223//if sqlnode实现了接口sqlnode的apply方法，//定义了自己的行为只有当test表达式为真的时候//才会将节点内容增加到动态上下文的sql拼接中public class IfSqlNode implements SqlNode &#123; private final ExpressionEvaluator evaluator; private final String test; private final SqlNode contents; public IfSqlNode(SqlNode contents, String test) &#123; this.test = test; this.contents = contents; this.evaluator = new ExpressionEvaluator(); &#125; @Override public boolean apply(DynamicContext context) &#123; if (evaluator.evaluateBoolean(test, context.getBindings())) &#123; contents.apply(context); return true; &#125; return false; &#125;&#125;mybatis一组复杂sql在xml文件中的配置12345678910111213141516171819202122232425&lt;!-- trim节点作为根节点，下面有三个if子节点，在Mybatis中组织成 一个根节点MixedNode节点下两个trim节点和where节点;trim节点 下一个MixedNode节点，由三个if节点组成;where节点实际上的trim 节点的另一种实现，原理一样 --&gt;&lt;update id=\"update\" parameterType=\"org.format.dynamicproxy.mybatis.bean.User\"&gt; UPDATE users &lt;trim prefix=\"SET\" prefixOverrides=\",\"&gt; &lt;if test=\"name != null and name != ''\"&gt; name = #&#123;name&#125; &lt;/if&gt; &lt;if test=\"age != null and age != ''\"&gt; , age = #&#123;age&#125; &lt;/if&gt; &lt;if test=\"birthday != null and birthday != ''\"&gt; , birthday = #&#123;birthday&#125; &lt;/if&gt; &lt;/trim&gt; &lt;where&gt; 1=1 &lt;if test=\"id != null\"&gt; and id = $&#123;id&#125; &lt;/if&gt; &lt;/where&gt;&lt;/update&gt;总结组合模式对于具有层次关系多个对象能够很好的表达，但是比较抽象不容易掌控。提高了软件设计困难同时屏蔽了对象复杂性，客户端使用变得简单","categories":[{"name":"框架工具","slug":"框架工具","permalink":"https://mxzenf123.github.io/index.html/categories/框架工具/"}],"tags":[{"name":"mybatis动态sql","slug":"mybatis动态sql","permalink":"https://mxzenf123.github.io/index.html/tags/mybatis动态sql/"},{"name":"组合设计模式","slug":"组合设计模式","permalink":"https://mxzenf123.github.io/index.html/tags/组合设计模式/"}]},{"title":"spring IoC和容器问题整理","slug":"springioc问题整理","date":"2019-10-27T06:44:07.570Z","updated":"2019-10-27T07:41:12.816Z","comments":true,"path":"2019/10/27/springioc问题整理/","link":"","permalink":"https://mxzenf123.github.io/index.html/2019/10/27/springioc问题整理/","excerpt":"","text":"什么是依赖注入以及有什么好处?什么是接口，在java中使用的好处spring bean中为什么推荐使用接口application-context代表什么？你怎么创建一个ApplicationContext实例？描述bean在ApplicationoContext的声明周期最好的关闭ApplicationContext的方式是什么？SpringBoot为我们做了这个吗？能够描述一下下面的问题使用java进行依赖注入使用注解进行依赖注入组件、模块扫描bean的scopebean是懒加载还是预实例化？你怎么控制这种行为？什么是属性源文件？你怎么使用@PropertySource什么是BeanFactoryPostProcessor，有什么用？它什么时候被调用？ProperySourcesPlaceholderConfigurer被用于什么地方？什么是组件扫描？@Autowired注解关于属性、构造器和方法做了什么？如果要向私有属性注入？怎么做到？@Qualifier对@Autowired做了什么补充？什么是对象代理？spring两种创建代理对象的区别？代理对象的限制？代理对象的功能和弊端？@Bean注解有什么用@Bean注解的Bean的默认id是什么？你如果改变？为什么不允许在final类上使用@Configration注解@Configration支持单例bean吗为什么@Bean注解的类的方法也不能是final的什么时候配置profile？在哪些场景会有用@Bean和@Profile能够同时使用吗？@Component和@Profile能够一起使用吗？你能够列举多少种profiles？怎么注入集合和k-v类型的数据到bean中？什么是SpringEL表达式？spring enviroment抽象是什么？$和#有什么区别？","categories":[{"name":"spring","slug":"spring","permalink":"https://mxzenf123.github.io/index.html/categories/spring/"}],"tags":[{"name":"spring IoC","slug":"spring-IoC","permalink":"https://mxzenf123.github.io/index.html/tags/spring-IoC/"},{"name":"spring容器","slug":"spring容器","permalink":"https://mxzenf123.github.io/index.html/tags/spring容器/"}]}]}