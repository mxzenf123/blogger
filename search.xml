<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mybatis二级缓存入门到精通]]></title>
    <url>%2F2021%2F03%2F06%2Fmybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%2F</url>
    <content type="text"><![CDATA[一级缓存是session级别的，缓存在一个session内部有效，如果要多个session共享缓存就需要开启二级缓存二级缓存是namespace级别的，不同的namespace不能够共享缓存入门demo开启二级缓存配置123&lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;/settings&gt;开启后executor会以代理模式创建，统一由CachingExecutor代理。mapper代理配置12345&lt;cache eviction="FIFO" size="1024" flushInterval="6000" /&gt;&lt;select id="getBlog" parameterType="string" resultType="map" useCache="true"&gt; select * from blog where id = #&#123;id&#125;&lt;/select&gt;现在来测试一下，两个不同的session是否共享了缓存1234567SqlSession sqlSession1 = ssf.openSession();SqlSession sqlSession2 = ssf.openSession();//两个不同的sessionAssert.assertNotEquals(sqlSession1,sqlSession2);sqlSession1.selectOne("org.yangxin.mapper1.getBlog","1");sqlSession1.commit();sqlSession2.selectOne("org.yangxin.mapper1.getBlog","1");日志输出结果:123456789DEBUG [main] - Cache Hit Ratio [org.yangxin.mapper1]: 0.0DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Setting autocommit to false on JDBC Connection [org.apache.derby.impl.jdbc.EmbedConnection@1530446316 (XID = 37309), (SESSIONID = 5), (DATABASE = ibderby), (DRDAID = null) ]DEBUG [main] - ==&gt; Preparing: select * from blog where id = ? DEBUG [main] - ==&gt; Parameters: 1(String)DEBUG [main] - &lt;== Total: 1DEBUG [main] - Cache Hit Ratio [org.yangxin.mapper1]: 0.5Process finished with exit code 0可以发现session2在并没有查询数据库来获取结果，实际就是访问的缓存。我们也可以配置mapperstatment中的select关闭缓存，只需将useCache改为false，默认为true123&lt;select id="getBlog" parameterType="string" resultType="map" useCache="false"&gt; select * from blog where id = #&#123;id&#125;&lt;/select&gt;运行代码查看控制台输出结果12345678910DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Setting autocommit to false on JDBC Connection [org.apache.derby.impl.jdbc.EmbedConnection@1222768327 (XID = 37411), (SESSIONID = 5), (DATABASE = ibderby), (DRDAID = null) ]DEBUG [main] - ==&gt; Preparing: select * from blog where id = ? DEBUG [main] - ==&gt; Parameters: 1(String)DEBUG [main] - &lt;== Total: 1DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Setting autocommit to false on JDBC Connection [org.apache.derby.impl.jdbc.EmbedConnection@220454978 (XID = 37415), (SESSIONID = 7), (DATABASE = ibderby), (DRDAID = null) ]DEBUG [main] - ==&gt; Preparing: select * from blog where id = ? DEBUG [main] - ==&gt; Parameters: 1(String)DEBUG [main] - &lt;== Total: 1关闭缓存后，我们看到控制台日志输出了两次通过Jdbc连接查询数据。遗留问题，update，delete，commit和rollback对二级缓存有什么影响，通过下面的源码分析我相信可以找到答案源码分析mybatis只有配置了cacheEnabled为true的时候才会生效二级缓存，这样所有的executor才能够被CachingExecutor代理123if (cacheEnabled) &#123; executor = new CachingExecutor(executor);&#125;CachingExecutor代理了所有executor方法，因为在执行各种ddl语句的时候会对二级缓存产生影响，其中主要管理二级缓存的类是TransactionalCacheManager12345678910111213141516171819202122232425262728293031323334353637383940public class TransactionalCacheManager &#123; //管理所有实现的Cache private Map&lt;Cache, TransactionalCache&gt; transactionalCaches = new HashMap&lt;Cache, TransactionalCache&gt;(); public void clear(Cache cache) &#123; getTransactionalCache(cache).clear(); &#125; public Object getObject(Cache cache, CacheKey key) &#123; return getTransactionalCache(cache).getObject(key); &#125; public void putObject(Cache cache, CacheKey key, Object value) &#123; getTransactionalCache(cache).putObject(key, value); &#125; //将本地缓存调用Cache的put方法使缓存生效 public void commit() &#123; for (TransactionalCache txCache : transactionalCaches.values()) &#123; txCache.commit(); &#125; &#125; //将所有未提交的缓存清空，将获取的缓存数据从缓存中移除 public void rollback() &#123; for (TransactionalCache txCache : transactionalCaches.values()) &#123; txCache.rollback(); &#125; &#125; private TransactionalCache getTransactionalCache(Cache cache) &#123; TransactionalCache txCache = transactionalCaches.get(cache); if (txCache == null) &#123; txCache = new TransactionalCache(cache); transactionalCaches.put(cache, txCache); &#125; return txCache; &#125;&#125;TransactionalCache又是代理类，将所实现的cache代理。executor执行影响缓存发放的时候都是由这个类去做相应的实现]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java spi入门及原理分析]]></title>
    <url>%2F2021%2F01%2F12%2Fspi%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[介绍维基百科解释查看wiki。spi全称Service privoder Interface，是java的第三方扩展机制。其中：数据库，jndi，声音服务，文件IO和图片IO都有应用代码demo先从简单的”hello world”开始来直观感受一下spi创建接口和实现该接口123456789101112131415/* * 创建接口 */ public interface IHelloWorld&#123; void say(String name); &#125;/* *实现类 */ public class HelloWorldImpl implements IHelloWorld &#123; @Override public void say(String name) &#123; System.out.println("hello," + name); &#125; &#125;配置文件在resources文件夹下新建META-INF/service，以接口IHelloWorld类全路径未文件命名:文件内容为实现类HelloWorldImpl的全路径名称测试代码123456789@Test//输出 hello worldpublic void spi_test()&#123; ServiceLoader&lt;IHelloWorld&gt; hs = ServiceLoader.load(IHelloWorld.class,Thread.currentThread().getContextClassLoader()); for (IHelloWorld helloWorld : hs) &#123; helloWorld.say("world"); &#125;&#125;原理查看ServiceLoader源码，其中主要有两个问题需要带着去阅读，解决了基本就明白了原理1，为什么要按照META-INI/service，接口文件名和实现类内容创建文件2，如何加载实现类直接上关键代码123456789/* *PREFIX = "META-INF/services/" *这段代码就解释了第一个问题 */String fullName = PREFIX + service.getName();if (loader == null) configs = ClassLoader.getSystemResources(fullName);else configs = loader.getResources(fullName);我在jdk1.8中查看源码，inputstream都实现了AutoCloseable，但是大佬们在解析接口命名的文件的时候没有使用try with resources方式，大佬们也有偷懒的时候啊123456789101112131415try &#123; in = u.openStream(); r = new BufferedReader(new InputStreamReader(in, "utf-8")); int lc = 1; while ((lc = parseLine(service, u, r, lc, names)) &gt;= 0);&#125; catch (IOException x) &#123; fail(service, "Error reading configuration file", x);&#125; finally &#123; try &#123; if (r != null) r.close(); if (in != null) in.close(); &#125; catch (IOException y) &#123; fail(service, "Error closing configuration file", y); &#125;&#125;第二个问题就是大家在熟悉不过的使用Class.forName在加载配置文件中的实现类了12345try &#123; c = Class.forName(cn, false, loader);&#125; catch (ClassNotFoundException x) &#123; fail(service,"Provider " + cn + " not found");&#125;至此spi就算入门了，查看了一下ojdbc.jar包，验证了确实也是以spi的方式提供的，有兴趣的朋友可以再验证一下文章开头所说的服务提供商是否也是spi实现的]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis分页原理]]></title>
    <url>%2F2019%2F12%2F21%2Fmybatis%E5%88%86%E9%A1%B5%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[mybatis分页原理在通过session查询数据的时候，根据传入的数据结构RowBounds来进行查询数据库结果集的skip和limit操作达到分页的目的mybatis分页相关代码RowBounds类12345678910111213141516171819202122232425262728public class RowBounds &#123; public static final int NO_ROW_OFFSET = 0;//默认 public static final int NO_ROW_LIMIT = Integer.MAX_VALUE;//默认 public static final RowBounds DEFAULT = new RowBounds();//默认 private int offset; private int limit; public RowBounds() &#123; this.offset = NO_ROW_OFFSET; this.limit = NO_ROW_LIMIT; &#125; public RowBounds(int offset, int limit) &#123; this.offset = offset; this.limit = limit; &#125; public int getOffset() &#123; return offset; &#125; public int getLimit() &#123; return limit; &#125;&#125;可以看出RowBounds类还是比较简单，offset和limit只有这两个成员属性，Mybatis分页主要也是根据这两个属性DefaultSqlSession根据RowBounds类进行分页查询123456789101112131415@Override public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) &#123; return this.selectList(statement, parameter, RowBounds.DEFAULT);&#125;public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123; try &#123; MappedStatement ms = configuration.getMappedStatement(statement); return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException("Error querying database. Cause: " + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125;&#125;如果不传入RowBounds那么使用默认的，offset从0开始，limit为Integer最大值DefaultResultSetHandler根据RowBounds进行返回结果集处理12345678910private void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException &#123; DefaultResultContext&lt;Object&gt; resultContext = new DefaultResultContext&lt;Object&gt;(); skipRows(rsw.getResultSet(), rowBounds);//1 while (shouldProcessMoreRows(resultContext, rowBounds)/*2*/ &amp;&amp; rsw.getResultSet().next()) &#123; ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(rsw.getResultSet(), resultMap, null); Object rowValue = getRowValue(rsw, discriminatedResultMap); storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet()); &#125;&#125;1，根据offset跳过结果集到指定行数2，根据limit获取指定数量的结果集总结mybatis自带分页实现较为简单，将所有结果查询出来，然后取固定某段结果。明显的缺点就是需要将结果全部查询出去，如果进行分页需要手动的去计算指定offset和limit，使用不是很方便。]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis分页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis一级缓存源码分析]]></title>
    <url>%2F2019%2F12%2F14%2Fmybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[源码分析mybatis的一级缓存是session级别默认开启的，如果使用不当不了解其原理会造成一些隐患。session在执行查询的时候委托给executor，一级缓存为起一个map结构的localCache变量实现。主要代码如下12345678//取缓存数据根据cacheKey，cacheKey数据结构感兴趣可以阅读源码list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;if (list != null) &#123; handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);&#125; else &#123; //没取到就查询数据库 list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);&#125;在queryFormDatabase方法中会put操作localCache将结果缓存。但是如果配置了参数localCacheScop为statement级别那么不会进行缓存1234if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123; // 清空localCache clearLocalCache();&#125;常见问题如果对于同一个命名空间select的id相同，不同session可能会存在脏读1234567891011121314//开启两个session//涉及的测试环境在mybatis源码中可以找到SqlSession session1 = sqlMapper.openSession();SqlSession session2 = sqlMapper.openSession();Blog blog1 = session1.selectOne("org.apache.ibatis.domain.blog.mappers.NestedBlogMapper.selectBlogJoinedWithPostsAndAuthor", 1);Blog blog2 = session2.selectOne("org.apache.ibatis.domain.blog.mappers.NestedBlogMapper.selectBlogJoinedWithPostsAndAuthor", 1);assertEquals("Jim Business", blog1.getTitle());assertEquals("Jim Business", blog2.getTitle());session1.update("org.apache.ibatis.domain.blog.mappers.NestedBlogMapper.upBlogId", 1);session1.commit();Blog blog3 = session1.selectOne("org.apache.ibatis.domain.blog.mappers.NestedBlogMapper.selectBlogJoinedWithPostsAndAuthor", 1);Blog blog4 = session2.selectOne("org.apache.ibatis.domain.blog.mappers.NestedBlogMapper.selectBlogJoinedWithPostsAndAuthor", 1);assertEquals("new title", blog4.getTitle());//失败 falseassertEquals("new title", blog3.getTitle());//成功 true上面代码实际上会测试失败，因为产生了脏读。]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apache commons-io IOUtils入门]]></title>
    <url>%2F2019%2F11%2F23%2FIOUtils%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[IOUtils提供了输入和输出的静态工具方法：toXXX/read 从流读取数据wirte 写入数据进流copy 流之间复制数据contentEquals 比较两个流IOUtils的所有方法都采取默认字符集，也可以指定字符集。从流读取数据都默认使用了Buffered流，意味着我们不需要额外进行流缓冲类使用。工具中，所有流都自动flush和close，不需要手动调用flush、close方法。]]></content>
      <categories>
        <category>apache commons</category>
      </categories>
      <tags>
        <tag>IOUtils</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么阿里巴巴禁止在foreach循环里进行元素的remove/add操作]]></title>
    <url>%2F2019%2F11%2F10%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E7%A6%81%E6%AD%A2%E5%9C%A8foreach%E5%BE%AA%E7%8E%AF%E9%87%8C%E8%BF%9B%E8%A1%8C%E5%85%83%E7%B4%A0%E7%9A%84removeadd%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[什么是fail-fast机制在wiki上关于fast-fail描述原文In systems design, a fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process. Such designs often check the system’s state at several points in an operation, so any failures can be detected early. The responsibility of a fail-fast module is detecting errors, then letting the next-highest level of the system handle them.大致意思，在做系统设计的时候，fail-fast能够快速报告故障。fail-fast设计用于停止正常的操作，而不是让潜在错误的程序继续运行。该设计在每一次操作上都检查系统状态，能够提前检测任何故障。fail-fast能够检测错误，并且把错误交给更高一级进行处理。一个简单的fail-fast例子1234567 public int divide(int divisor, int dividend)&#123; if (dividend == 0)&#123; throw new RuntimeException("除数不能为0");&#125;return divisor / dividend; &#125;fail-fast不要被这个专业术语所唬住，实际上很简单。就是对代码可能出现的一些错误提前预判罢了foreach语法糖在java较早的时候对于List集合循环我们大多使用这样123for (int i = list.size()-1;i &gt;= 0 ;i--)&#123; ...&#125;java给我们提供了一个foreach语法糖便利的来对集合进行遍历123for (String s : list) &#123; ...&#125;这个语法糖原理实际上是使用了List中自带的Iterator实现。但是这个留下了一个巨坑，就是在遍历的时候如果list.remove(o)方法会抛出java.util.ConcurrentModificationException异常。明明没有多线程操作啊，怎么会有这个异常，让人一脸懵逼。ArrayList集合fail-fast保护实现1，由于ArrayList不是线程安全的，在每次对集合进行操作的时候会调用一个这样的方法：1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;modCount是ArrayList的成员变量代表对集合操作次数；expectedModCount理论上是和modCount一样的2，在使用Iterator迭代集合的时候，如果调用的ArrayList的remove方法，会有个这样的操作modCount++，这个时候checkForComodification检查失败所以抛出了ConcurrentModificationException异常]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>fail-fast机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java自动拆装箱问题总结]]></title>
    <url>%2F2019%2F11%2F03%2Fjava%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[java自动拆装箱自jdk1.5以后新增功能。目的是为了解决基础数据类型和对象操作不便利。比如集合List只能操作对象，而无法对基本数据类型进行add，remove等一系列操作。对自动拆装箱学习过程中，产生了一系列疑问，总结如下什么是基础数据类型，什么是包装类jdk如何实现自动拆装箱自动拆装箱优点和缺点自动拆装箱什么时候不自动进行]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java自动拆装箱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Integer的缓存机制]]></title>
    <url>%2F2019%2F11%2F02%2FInteger%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021public class JavaIntegerCache &#123; public static void main(String... strings) &#123; Integer integer1 = 3; Integer integer2 = 3; if (integer1 == integer2) System.out.println("integer1 == integer2"); else System.out.println("integer1 != integer2"); Integer integer3 = 300; Integer integer4 = 300; if (integer3 == integer4) System.out.println("integer3 == integer4"); else System.out.println("integer3 != integer4"); &#125;&#125;由于Integer是对象，两个对象比较，我们普遍的认为上面的两个结果都是false然而结果却会让你大跌眼镜。上面这段代码真正的输出结果：12integer1 == integer2integer3 != integer4原因就在于java5.0以后对于基本类型自动装箱的在范围-127到128之间会进行自动缓存以提升程序性能]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java自动装箱</tag>
        <tag>java缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis动态sql之组合模式]]></title>
    <url>%2F2019%2F11%2F02%2Fmybatis%E5%8A%A8%E6%80%81sql%E5%AE%9E%E7%8E%B0%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[组合设计模式组合设计模式是一种整体与部分的树形层次关系结构。组合对象中各个对象具有相同的行为模式，这样就能处理简单对象一样处理复杂对象。复杂对象的底层细节将会被屏蔽掉，与客户端解耦，最重要的是和简单对象一样实现了同一个接口mybatis动态sql实现同一个接口1234public interface SqlNode &#123; //共同的行为 boolean apply(DynamicContext context);&#125;复杂对象12345678910111213141516 //混合sqlnode节点，组合不同类型的sqlnode //其他node有：trim,set,where,if,otherwise //choose public class MixedSqlNode implements SqlNode &#123; private final List&lt;SqlNode&gt; contents;public MixedSqlNode(List&lt;SqlNode&gt; contents)&#123; this.contents = contents;&#125;@Overridepublic boolean apply(DynamicContext context)&#123; contents.forEach(node -&gt; node.apply(context)); return true;&#125; &#125;简单对象1234567891011121314151617181920212223//if sqlnode实现了接口sqlnode的apply方法，//定义了自己的行为只有当test表达式为真的时候//才会将节点内容增加到动态上下文的sql拼接中public class IfSqlNode implements SqlNode &#123; private final ExpressionEvaluator evaluator; private final String test; private final SqlNode contents; public IfSqlNode(SqlNode contents, String test) &#123; this.test = test; this.contents = contents; this.evaluator = new ExpressionEvaluator(); &#125; @Override public boolean apply(DynamicContext context) &#123; if (evaluator.evaluateBoolean(test, context.getBindings())) &#123; contents.apply(context); return true; &#125; return false; &#125;&#125;mybatis一组复杂sql在xml文件中的配置12345678910111213141516171819202122232425&lt;!-- trim节点作为根节点，下面有三个if子节点，在Mybatis中组织成 一个根节点MixedNode节点下两个trim节点和where节点;trim节点 下一个MixedNode节点，由三个if节点组成;where节点实际上的trim 节点的另一种实现，原理一样 --&gt;&lt;update id="update" parameterType="org.format.dynamicproxy.mybatis.bean.User"&gt; UPDATE users &lt;trim prefix="SET" prefixOverrides=","&gt; &lt;if test="name != null and name != ''"&gt; name = #&#123;name&#125; &lt;/if&gt; &lt;if test="age != null and age != ''"&gt; , age = #&#123;age&#125; &lt;/if&gt; &lt;if test="birthday != null and birthday != ''"&gt; , birthday = #&#123;birthday&#125; &lt;/if&gt; &lt;/trim&gt; &lt;where&gt; 1=1 &lt;if test="id != null"&gt; and id = $&#123;id&#125; &lt;/if&gt; &lt;/where&gt;&lt;/update&gt;总结组合模式对于具有层次关系多个对象能够很好的表达，但是比较抽象不容易掌控。提高了软件设计困难同时屏蔽了对象复杂性，客户端使用变得简单]]></content>
      <categories>
        <category>框架工具</category>
      </categories>
      <tags>
        <tag>mybatis动态sql</tag>
        <tag>组合设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring IoC和容器问题整理]]></title>
    <url>%2F2019%2F10%2F27%2Fspringioc%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是依赖注入以及有什么好处?什么是接口，在java中使用的好处spring bean中为什么推荐使用接口application-context代表什么？你怎么创建一个ApplicationContext实例？描述bean在ApplicationoContext的声明周期最好的关闭ApplicationContext的方式是什么？SpringBoot为我们做了这个吗？能够描述一下下面的问题使用java进行依赖注入使用注解进行依赖注入组件、模块扫描bean的scopebean是懒加载还是预实例化？你怎么控制这种行为？什么是属性源文件？你怎么使用@PropertySource什么是BeanFactoryPostProcessor，有什么用？它什么时候被调用？ProperySourcesPlaceholderConfigurer被用于什么地方？什么是组件扫描？@Autowired注解关于属性、构造器和方法做了什么？如果要向私有属性注入？怎么做到？@Qualifier对@Autowired做了什么补充？什么是对象代理？spring两种创建代理对象的区别？代理对象的限制？代理对象的功能和弊端？@Bean注解有什么用@Bean注解的Bean的默认id是什么？你如果改变？为什么不允许在final类上使用@Configration注解@Configration支持单例bean吗为什么@Bean注解的类的方法也不能是final的什么时候配置profile？在哪些场景会有用@Bean和@Profile能够同时使用吗？@Component和@Profile能够一起使用吗？你能够列举多少种profiles？怎么注入集合和k-v类型的数据到bean中？什么是SpringEL表达式？spring enviroment抽象是什么？$和#有什么区别？]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring IoC</tag>
        <tag>spring容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[intellij常用快捷键]]></title>
    <url>%2F2019%2F10%2F13%2Fintellij%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[常规Ctrl+X，删除行Ctrl+D，复制行Ctrl+Alt+O，优化导入的类和包Ctrl+Alt+L，格式化代码Ctrl+Shift+F，全局查找，类似Eclipse中的Ctrl+H查找Ctrl+H，显示类结构图（类的继承层次）Ctrl+F12，可以显示当前文件的结构（structure包括属性和方法）Alt+Q，可以看到当前方法的声明Ctrl+Q，显示注释文档Ctrl+P，可以显示参数信息Ctrl+N，可以快速打开类Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）Ctrl+Alt+B，跳转到方法实现处Alt+左箭头，跳转到上次编辑的地方Shift+F6，重命名Alt+Shift+Up/Down，上/下移一行Ctrl+Shift+U，大小写转化调试F8，步过F7，步入Shift+F7，智能步入Shift+F8，步出Alt+Shift+F8，强制步过Alt+Shift+F7，强制步入Alt+F9，运行至光标处Ctrl+Alt+F9，强制运行至光标处F9，恢复程序查找Ctrl+F，查找Ctrl+R，替换Alt+F7，查找用法Ctrl+Alt+F7，显示用法Ctrl+F7，在文件中查找用法r]]></content>
      <categories>
        <category>奇淫技巧</category>
      </categories>
      <tags>
        <tag>intellij快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apache BeanUtils入门]]></title>
    <url>%2F2019%2F10%2F13%2Fapache_beanutils%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[apache项目地址site背景在我们使用java开发过程中，对于操作类的属性一般通过get或者set两个方法，类似于Object.get()/set()。但是有的时候我们可能不能够直接调用这两个方法获取类的属性，也许第一反应是用reflection，这样会自己写太多和业务无关的代码。apache commons包中BeanUtils能够帮助我们解决这个问题。准备工作引入apache commons-beanutils包新建类Empolyee12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Employee &#123; public String firstName; public String lastName; public String[] tells; public Map address; public Employee()&#123; tells = new String[10]; address = new HashMap(); &#125; public String getFirstName() &#123; return firstName; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String[] getTells() &#123; return tells; &#125; public void setTells(String[] tells) &#123; this.tells = tells; &#125; public Map getAddress() &#123; return address; &#125; public void setAddress(Map address) &#123; this.address = address; &#125;&#125;开始使用这篇文章我们主要介绍该工具包中PropertyUtils入门使用简单属性123Employee employee = new Employee();PropertyUtils.setSimpleProperty(employee, "firstName", "欣");PropertyUtils.setSimpleProperty(employee, "lastName", "杨");带索引的属性123Employee employee = new Employee();PropertyUtils.setIndexedProperty(employee, "tells[0]", "110");PropertyUtils.setIndexedProperty(employee, "tells[1]", "120");key-value属性123Employee employee = new Employee();PropertyUtils.setMappedProperty(employee, "address(province)", "四川省");PropertyUtils.setMappedProperty(employee, "address(city)", "成都");]]></content>
      <categories>
        <category>框架工具</category>
      </categories>
      <tags>
        <tag>apache commons</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo搭建个人博客]]></title>
    <url>%2F2019%2F09%2F28%2F%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Quick start参考官网文档快速开始创建博客文件夹1$ hexo new "My New Post"更多: 创建启动本地服务1$ hexo server更多: 服务器生成静态文件1$ hexo generate更多: 生成静态文件发布到远程服务器1$ hexo deploy更多: 发布]]></content>
      <categories>
        <category>奇淫技巧</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
