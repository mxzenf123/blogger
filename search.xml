<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[多线程和共享资源问题]]></title>
    <url>%2F2021%2F07%2F11%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[jvm和java线程java所有的线程都工作在一个jvm实例下，jvm为每个线程运行分配所需要的空间：栈和堆。堆是jvm分配所有线程共享存储对象的区域，线程栈保存着线程运行时信息。如果多个线程同时对堆中分配对象（基本数据类型）进行操作，就会发生多线程共享问题线程共享资源我们写一个功能为两个线程同时累加一个变量500万次，最后输出累加结果，我们期望的结果是1000万，最后的结果是否和我们期望的一致呢？1234567891011121314static int sum = 0;Runnable r1 = ()-&gt;&#123; for (int i = 0;i &lt; 500*10000;i++) &#123; sum++; &#125;&#125;;Thread thread1 = new Thread(r1);Thread thread2 = new Thread(r1);thread1.start();thread2.start();thread1.join();thread2.join();log.debug("累加结果：" + sum);我们定义了一静态int变量并初始化为0。定义了一段可执行代码对sum自增500万次。创建两个线程执行它，并在main线程中等待这两个线程执行完毕后输出结果12021-07-11 15:45:07.574 [main] DEBUG org.yangxin.thread.ThreadTest:102 - 累加结果：5358584输出结果和我们预期相差的天远地远，不管我们运行多少次上面的代码，输出结果可能不同，但是几乎没有一次是我们期望的结果1000万，那么问题到底出在哪里呢？多线程访问共享变量的秘密上面代码中可执行代码sum++实际有三个操作，首先是把sum的值取出来，然后加1，把加到的结果再赋值给sum变量。执行这段代码的两个线程thread1和thread2，可能出现如果sum=0的时候，两个线程同时执行这段代码thread1将sum变量副本值0拷贝到自己本地，同时thread2也将sum变量副本值0，thread1执行完后sum=1再将该值拷贝到堆中，thread2也做同样的操作，这个时候sum为1而不是2改进后的代码我们将sum++自增操作放在关键字synchronized代码块中再来运行观察结果123synchronized (ThreadTest.class) &#123; sum++;&#125;12021-07-11 16:11:01.626 [main] DEBUG org.yangxin.thread.ThreadTest:104 - 累加结果：10000000结果终于达到了我们的预期输出了1000万竞态条件和临界区多线程操作同一资源（写）时，如果对于先后顺序敏感，就称存在竞态条件。导致竞态条件变化的代码块叫做临界区。上述代码中sum就是一个竞态条件，sum++就是一个临界区，代码中加入了同步关键字synchronized同步来解决，更多java同步和锁的内容会在后续文章继续介绍]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread类的join方法]]></title>
    <url>%2F2021%2F06%2F27%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%94%81%2F</url>
    <content type="text"><![CDATA[如果两个线程A和B，线程A要等待线程B执行完后再继续执行，那么可以在线程A中调用线程B实例的join方法。现在通过代码来直观感受一下，在main线程中创建demo1线程，并调用demo1线程的join方法。1234567891011121314log.debug(Thread.currentThread().getName() + "开始");Thread thread1 = new Thread(()-&gt;&#123; try &#123; log.debug(Thread.currentThread().getName() + "开始"); Thread.sleep(2000); log.debug(Thread.currentThread().getName() + "结束"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;,"demo1");thread1.start();thread1.join();log.debug(Thread.currentThread().getName() + "结束");控制台输出12342021-06-20 10:56:39.620 [main] DEBUG org.yangxin.thread.ThreadTest:86 - main开始2021-06-20 10:56:39.668 [demo1] DEBUG org.yangxin.thread.ThreadTest:90 - demo1开始2021-06-20 10:56:41.680 [demo1] DEBUG org.yangxin.thread.ThreadTest:92 - demo1结束2021-06-20 10:56:41.681 [main] DEBUG org.yangxin.thread.ThreadTest:100 - main结束可以看到运行结果和我们预想的输出顺序基本一致，main线程在结束前调用demo1.join，demo1线程sleep2秒后执行完毕，main线程继续完成执行。如果join的线程执行时间未知，main线程可能永远的等待下去，这个时候我们希望等待一定的时间不管join的线程是否执行完毕，main线程继续往下执行，代码可更改在调用thread1.jion方法时加上参数thread1.join(1000)：1thread1.join(1000);main线程等待demo1线程1秒钟，1秒钟后main线程继续执行12342021-06-20 11:29:53.055 [main] DEBUG org.yangxin.thread.ThreadTest:86 - main开始2021-06-20 11:29:53.105 [demo1] DEBUG org.yangxin.thread.ThreadTest:89 - demo1开始2021-06-20 11:29:54.119 [main] DEBUG org.yangxin.thread.ThreadTest:99 - main结束2021-06-20 11:29:55.110 [demo1] DEBUG org.yangxin.thread.ThreadTest:95 - demo1开始控制台输出demo1开始执行后，main等待了1秒钟然后继续执行并输出执行完毕，再过了一秒钟demo1执行完毕。join还遗留了一个问题，main线程何时怎么样被notify的；查看了start方法，里面并没有notify的代码，初步推断是在start0这个native方法里面唤醒的main线程]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread类的join方法]]></title>
    <url>%2F2021%2F06%2F20%2FThread%E7%B1%BB%E7%9A%84join%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[如果两个线程A和B，线程A要等待线程B执行完后再继续执行，那么可以在线程A中调用线程B实例的join方法。现在通过代码来直观感受一下，在main线程中创建demo1线程，并调用demo1线程的join方法。1234567891011121314log.debug(Thread.currentThread().getName() + "开始");Thread thread1 = new Thread(()-&gt;&#123; try &#123; log.debug(Thread.currentThread().getName() + "开始"); Thread.sleep(2000); log.debug(Thread.currentThread().getName() + "结束"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;,"demo1");thread1.start();thread1.join();log.debug(Thread.currentThread().getName() + "结束");控制台输出12342021-06-20 10:56:39.620 [main] DEBUG org.yangxin.thread.ThreadTest:86 - main开始2021-06-20 10:56:39.668 [demo1] DEBUG org.yangxin.thread.ThreadTest:90 - demo1开始2021-06-20 10:56:41.680 [demo1] DEBUG org.yangxin.thread.ThreadTest:92 - demo1结束2021-06-20 10:56:41.681 [main] DEBUG org.yangxin.thread.ThreadTest:100 - main结束可以看到运行结果和我们预想的输出顺序基本一致，main线程在结束前调用demo1.join，demo1线程sleep2秒后执行完毕，main线程继续完成执行。如果join的线程执行时间未知，main线程可能永远的等待下去，这个时候我们希望等待一定的时间不管join的线程是否执行完毕，main线程继续往下执行，代码可更改在调用thread1.jion方法时加上参数thread1.join(1000)：1thread1.join(1000);main线程等待demo1线程1秒钟，1秒钟后main线程继续执行12342021-06-20 11:29:53.055 [main] DEBUG org.yangxin.thread.ThreadTest:86 - main开始2021-06-20 11:29:53.105 [demo1] DEBUG org.yangxin.thread.ThreadTest:89 - demo1开始2021-06-20 11:29:54.119 [main] DEBUG org.yangxin.thread.ThreadTest:99 - main结束2021-06-20 11:29:55.110 [demo1] DEBUG org.yangxin.thread.ThreadTest:95 - demo1开始控制台输出demo1开始执行后，main等待了1秒钟然后继续执行并输出执行完毕，再过了一秒钟demo1执行完毕。join还遗留了一个问题，main线程何时怎么样被notify的；查看了start方法，里面并没有notify的代码，初步推断是在start0这个native方法里面唤醒的main线程]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程的状态]]></title>
    <url>%2F2021%2F06%2F06%2F%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[jdk的Thread源码中对线程的状态进行了六种定义，分别是：NEW线程已经被创建也就是new出来，但是并没执行RUNNABLEThread调用了start的方法，但是不代表线程立马执行，而是可执行状态。在单核CPU的电脑下，CPU每次只能够执行一个线程，所以不是所有线程并不是都可以立马执行。有的也把这个状态拆分为两个状态：RUNNING和READY，这两个状态在JDK中是没有的是人为的方便理解BLOCKED线程在等待一个monitor lock，多个线程执行使用了synchronized的代码块（方法）。其他线程获得了这个monitor lock，那么这个线程执行同步代码块获得锁之前的状态WAITING当前线程执行代码条调用了特定的方法会进行等待状态：Object.waitThread.joinLockSupport.part()TIMED_WAITING在当前线程执行代码中调用了特定的方法指定等待时间：Thread.sleepObject.waitThread.joinLockSupport.parkNanosLockSupport.parkUntilTERMINATED线程执行完毕上面的所有状态都从NEW开始，TERMINATED结束，其他状态不一定每个状态都会经历，每个状态可以经历多次也可以一次也不经历。下面用代码的形式结果虚拟机指令jps和jstack来观察线程不同情况下的状态12345new Thread( ()-&gt;&#123; while (true) &#123; //干点什么 &#125;&#125;, "demo1").start();上面代码直接创建了一个名为demo1的线程，代码很简洁，直接无限while，现在通过虚拟机来观察线程状态“demo1” #12 prio=5 os_prio=0 tid=0x000001e89e2cf000 nid=0x20f4 runnable [0x00000082d4eff000]java.lang.Thread.State: RUNNABLEat org.yangxin.thread.ThreadTest.lambda$main$4(ThreadTest.java:81)at org.yangxin.thread.ThreadTest$$Lambda$1/109961541.run(Unknown Source)at java.lang.Thread.run(Thread.java:748)可以看到demo1线程处于RUNNABLE状态synchronized关键字可以修饰方法也可以修饰代码块（static），修饰对象不一样对应的锁也不一样。Object的wait方法只能够在synchronized中使用，如果锁的对象和wait对象不一致，运行会报错12345678910111213141516171819202122Object lock = new Object();Object o = new Object();new Thread( ()-&gt;&#123; synchronized (lock) &#123; try &#123; System.out.println(Thread.currentThread().getName() + "：我在waiting"); o.wait(); System.out.println(Thread.currentThread().getName() + "：我被唤醒了"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;, "demo1").start();new Thread( ()-&gt;&#123; try &#123; synchronized (lock) &#123; Thread.sleep(2*1000); o.notifyAll(); System.out.println(Thread.currentThread().getName() + "：我把你们都唤醒了"); &#125; &#125; catch (Exception e) &#123;&#125;&#125;, "demo2").start();上面的代码创建了两个锁对象，线程demo1和demo2使用lock锁执行了一段同步代码。demo1线程调用了另一个锁对象的wait方法等待被notify，线程demo2sleep两秒后调用对象o的notifyAll方法让demo1执行，运行上面代码，控制台输出123456demo1：我在waitingException in thread &quot;demo1&quot; java.lang.IllegalMonitorStateException at java.lang.Object.wait(Native Method) at java.lang.Object.wait(Object.java:502) at org.yangxin.thread.ThreadTest.lambda$main$4(ThreadTest.java:86) at java.lang.Thread.run(Thread.java:748)抛出了异常，demo1中o.wait方法，这就说明了synchronized关键字执行代码块里不能够使用其他对象的wait方法，当然离开synchronized直接执行Object.wait也是不行的。我们把上面代码中对象o.wait和o.notifyAll更换为lock.wait和lock.notifyAll再次运行查看线程状态1234567891011121314151617"demo2" #13 prio=5 os_prio=0 tid=0x0000019fcee3b000 nid=0x24a8 waiting on condition [0x00000012dceff000] java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(Native Method) at org.yangxin.thread.ThreadTest.lambda$main$5(ThreadTest.java:97) - locked &lt;0x000000076bd585d8&gt; (a java.lang.Object) at org.yangxin.thread.ThreadTest$$Lambda$2/670700378.run(Unknown Source) at java.lang.Thread.run(Thread.java:748)"demo1" #12 prio=5 os_prio=0 tid=0x0000019fcee2d800 nid=0x2354 in Object.wait() [0x00000012dcdff000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x000000076bd585d8&gt; (a java.lang.Object) at java.lang.Object.wait(Object.java:502) at org.yangxin.thread.ThreadTest.lambda$main$4(ThreadTest.java:86) - locked &lt;0x000000076bd585d8&gt; (a java.lang.Object) at org.yangxin.thread.ThreadTest$$Lambda$1/193064360.run(Unknown Source) at java.lang.Thread.run(Thread.java:748)可以看到demo1已经处于WAITING状态了，由于demo2调用了sleep方法所以线程处于TIMED_WAITING状态。请注意demo1线程中locked &lt;0x000000076bd585d8&gt; (a java.lang.Object) 和 - waiting on &lt;0x000000076bd585d8&gt; (a java.lang.Object)，对应的demo2中的 - locked &lt;0x000000076bd585d8&gt; (a java.lang.Object)，两个线程都和同一把锁关联，demo1调用wait方法后释放锁进入WAITING状态继续等待获取该锁，demo2持有锁TIMED-WAITING执行完成后释放锁。对上面代码去掉wait和notifyAll方法后调整如下：1234567891011121314151617Object lock = new Object();new Thread( ()-&gt;&#123; try &#123; Thread.sleep(2*2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock) &#123; &#125;&#125;, "demo1").start();new Thread( ()-&gt;&#123; try &#123; synchronized (lock) &#123; while (true); &#125; &#125; catch (Exception e) &#123;&#125;&#125;, "demo2").start();线程demo1调用sleep保证demo2获取到锁，demo2获取到锁后进入while循环，两线程状态如下：12345678910111213"demo2" #13 prio=5 os_prio=0 tid=0x0000012dd94cb800 nid=0x326c runnable [0x0000000bdbdfe000] java.lang.Thread.State: RUNNABLE at org.yangxin.thread.ThreadTest.lambda$main$5(ThreadTest.java:96) - locked &lt;0x000000076bd583d8&gt; (a java.lang.Object) at org.yangxin.thread.ThreadTest$$Lambda$2/670700378.run(Unknown Source) at java.lang.Thread.run(Thread.java:748)"demo1" #12 prio=5 os_prio=0 tid=0x0000012dd94ca800 nid=0x35b8 waiting for monitor entry [0x0000000bdbcff000] java.lang.Thread.State: BLOCKED (on object monitor) at org.yangxin.thread.ThreadTest.lambda$main$4(ThreadTest.java:90) - waiting to lock &lt;0x000000076bd583d8&gt; (a java.lang.Object) at org.yangxin.thread.ThreadTest$$Lambda$1/193064360.run(Unknown Source) at java.lang.Thread.run(Thread.java:748)可以看到demo1处于BLOCKED状态等待demo2释放锁。写到最后，从网上找到一份线程状态和调用对应方法的状态图供参考]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程的休眠]]></title>
    <url>%2F2021%2F05%2F30%2F%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%91%E7%9C%A0%2F</url>
    <content type="text"><![CDATA[线程Thread提供了一个sleep方法，让线程停止请求CPU执行，等待指定的时间后再继续执行。我的jdk1.8版本，sleep在jdk中源码，是一个native方法12345678910111213141516171819/*** Causes the currently executing thread to sleep (temporarily cease* execution) for the specified number of milliseconds, subject to* the precision and accuracy of system timers and schedulers. The thread* does not lose ownership of any monitors.* ** @param millis* the length of time to sleep in milliseconds** @throws IllegalArgumentException* if the value of &#123;@code millis&#125; is negative** @throws InterruptedException* if any thread has interrupted the current thread. The* &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is* cleared when this exception is thrown.*/public static native void sleep(long millis) throws InterruptedException;代码说明主要表达有3点当前线程在指定时间内暂停执行不会释放自己获得的监视器（锁）sleep是响应中断的线程休眠线程从调用start方法就会一直执行下去直到执行完成，如果我们想让线程暂停一会儿不抢占CPU执行，可以调用sleep方法123456789101112new Thread( ()-&gt;&#123; while (true)&#123; try &#123; //业务代码 //do somethings Thread.sleep(1*1000); System.out.println(LocalTime.now()+":sleep了1秒钟"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;, "demo1").start();我们会看到控制台输出：123416:03:39.494:sleep了1秒钟16:03:40.508:sleep了1秒钟16:03:41.522:sleep了1秒钟16:03:42.536:sleep了1秒钟上面代码每个一秒钟输出一次，从输出来看确实也是差不多每个一秒执行一次我们来看看线程sleep的状态123456"demo1" #12 prio=5 os_prio=0 tid=0x0000024f3a16b800 nid=0x2354 waiting on condition [0x000000c6153ff000] java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(Native Method) at org.yangxin.thread.ThreadTest.lambda$main$3(ThreadTest.java:58) at org.yangxin.thread.ThreadTest$$Lambda$1/109961541.run(Unknown Source) at java.lang.Thread.run(Thread.java:748)sleep后线程的状态为TIME_WAITING和jdk中描述的一致sleep会释放锁吗我们创建两个线程，synchronized通过关键字获取锁执行线程代码，第一个线程demo1获取锁后立马长时间sleep(20秒)，紧接着第二个线程执行，如果sleep线程释放锁，我们会1秒后立马看到第二个demo2线程输出，代码如下1234567891011121314151617181920212223Object lock = new Object();new Thread( ()-&gt;&#123; synchronized (lock) &#123; System.out.println("demo1获取了锁"); try &#123; Thread.sleep(20*1000); System.out.println("demo1执行完毕"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;, "demo1").start();new Thread( ()-&gt;&#123; try &#123; Thread.sleep(1*1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock) &#123; System.out.println("demo2获取到了锁"); System.out.println("demo2执行完毕"); &#125;&#125;,"demo2").start();代码执行时候我们通过虚拟机命令查看线程状态：1234567891011121314"demo2" #13 prio=5 os_prio=0 tid=0x0000013320fee800 nid=0x30e4 waiting for monitor entry [0x0000000f9c0ff000] java.lang.Thread.State: BLOCKED (on object monitor) at org.yangxin.thread.ThreadTest.lambda$main$4(ThreadTest.java:75) - waiting to lock &lt;0x000000076bd56eb8&gt; (a java.lang.Object) at org.yangxin.thread.ThreadTest$$Lambda$2/670700378.run(Unknown Source) at java.lang.Thread.run(Thread.java:748)"demo1" #12 prio=5 os_prio=0 tid=0x0000013320fea000 nid=0x25a0 waiting on condition [0x0000000f9bffe000] java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(Native Method) at org.yangxin.thread.ThreadTest.lambda$main$3(ThreadTest.java:60) - locked &lt;0x000000076bd56eb8&gt; (a java.lang.Object) at org.yangxin.thread.ThreadTest$$Lambda$1/193064360.run(Unknown Source) at java.lang.Thread.run(Thread.java:748)线程的虚拟机状态已经说明了一切，demo2线程仍然是BLOCKED状态，正在等待demo1获取的锁lock；demo1在等待sleep结束时间并持有锁lock。控制台输出也印证了我们的分析：123416:28:02.349，demo1获取了锁16:28:22.364，demo1执行完毕16:28:22.364，demo2获取到了锁16:28:22.364，demo2执行完毕]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[守护线程]]></title>
    <url>%2F2021%2F05%2F23%2F%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[在java中只有两类线程，用户线程和守护线程。守护线程编程者也可以自己创建，本质上这两类线程没有区别。唯一的联系就是，如果用户线程都执行完了，那么守护线程也没有存在的价值了，引入jvm一段话：The Java Virtual Machine exits when the only threads running are all daemon threads.JVM大意是java虚拟机会在所有线程都是守护线程的情况下退出如何使用守护线程一，如何设置线程为守护线程在创建线程start之前使用Thread的setDaemon(boolean on)方法。线程start后是无法设为守护线程的并且会报错123456789Thread thread1 = new Thread(()-&gt;&#123;&#125;);thread1.start();thread1.setDaemon(true);//报错/* *控制台输出 Exception in thread "main" java.lang.IllegalThreadStateException at java.lang.Thread.setDaemon(Thread.java:1359) at org.yangxin.thread.ThreadTest.main(ThreadTest.java:52) */如果某个线程已经是守护线程了，是否可以让他变为用户线程？答案肯定是否定的，看这段测试代码1234567891011121314151617181920212223242526Thread thread1 = new Thread(()-&gt;&#123; while (true) &#123; try &#123; System.out.println("我是守护线程，我开始守护"); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;);thread1.setDaemon(true);thread1.start();new Thread(()-&gt;&#123; while (true) &#123; try &#123; Thread.sleep(3000); if (thread1.isDaemon()) &#123; System.out.println("我不需要你守护了"); thread1.setDaemon(false); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;).start();代码开始创建一个线程为守护线程并每2描述输出一次内容到控制台，第二个为普通的用户线程，每三秒钟检测一次thread1是否为守护线程，如果是就调用thread1.setDaemon(false)方法尝试把thead1设置为非守护线程，然而事与愿违，在守护线程输出第二次内容到控制台的时候，第二个线程却报错了1234567我是守护线程，我开始守护我是守护线程，我开始守护我不需要你守护了Exception in thread "Thread-1" java.lang.IllegalThreadStateException at java.lang.Thread.setDaemon(Thread.java:1359) at org.yangxin.thread.ThreadTest.lambda$main$4(ThreadTest.java:69) at java.lang.Thread.run(Thread.java:748)我们看看Thread的setDaemon方法1234567public final void setDaemon(boolean on) &#123; checkAccess(); if (isAlive()) &#123; throw new IllegalThreadStateException(); &#125; daemon = on;&#125;这个方法有个检测isAlive，是个native方法，这同时也解释了为什么要在start之前调用setDaemon方法把用户线程变为守护线程且一旦线程启动就无法变回用户方法，感兴趣的还可以继续实验在setDaemon(true)后立马setDaemon(false)是否成功二，守护线程正确使用姿势守护线程往往是对用户线程进行服务的而不应该有业务代码，可以回收资源，作为调度线程来使用，因为一但用户线程完成了工作，守护线程如果还有像写文件网络数据读取任务，那么可能发生意想不到的后果。123456789101112Thread thread1 = new Thread(()-&gt;&#123; try &#123; FileOutputStream fos = new FileOutputStream(new File("e:" + File.separator+"1.txt")); fos.write("hello thread daemon".getBytes()); Thread.sleep(1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); thread1.setDaemon(true); thread1.start();这段代码在守护线程中写入”hello thread daemon”到文件1.txt中去，运行后却发现文件中没有任何内容，因为根本来不及写数据到磁盘中虚拟机就退出了]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建并运行线程]]></title>
    <url>%2F2021%2F05%2F09%2F%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概述在java中创建线程（运行时代码）有三种继承Thread，覆写run方法实现Runnable接口，实现runnable实现Callable接口，实现其call方法上面的每种创建方式如果运行时代码会排除检查异常需要进行try处理。1和2都没有返回结果，3执行后有返回结果。实际创建线程的方式只有一种，就是创建Thread对象，上面的方式只是创建了线程运行时的代码，这是一个很容易混肴的概念。编写线程运行时代码继承Thread类继承Thread类并且覆写run方法123456class Mythread extends Thread&#123; @Override public void run() &#123; System.out.println("自定义Thread类运行"); &#125;&#125;直接实例化MyThread类后调用start方法可以启动一个线程12Mythread mythread = new Mythread();mythread.start();如果在main函数中运行，那么在调用start后main线程会继续执行并等待myThread线程执行完毕，执行后控制台会输出1自定义Thread类运行实现Runnable接口新建MyThread1类并实现java.lang.Runnable接口1234567class MyThread1 implements Runnable&#123; @Override public void run() &#123; System.out.println("实现Runnable接口线程运行"); &#125;&#125;`这仅仅是提供的线程运行时代码，为了使线程执行MyThread1类中的run方法，这里需要借助Therad类1234567Thread thread = new Thread(new MyThread1());thread.start();/* 控制台输出: 实现Runnable接口线程运行 */借助java8函数式接口功能也可以这样方便的通过Runnable来提供线程运行时代码来让线程来执行123new Thread( ()-&gt;&#123; System.out.println("实现Runnable接口线程运行");&#125;).start();这段代码和上面代码输出结果一样常见错误如果对运行时代码理解程度不够不管用哪种方式创建线程可能会出现以下错误1thread.run();直接代码中调用run方法，虽然在本例中输出结果一样，但是有本质的区别，为了演示这个区别，对上面代码做如下调整123456789class MyThread1 implements Runnable&#123; @Override public void run() &#123; System.out.println("当前线程："+Thread.currentThread().getName()+",实现Runnable接口线程运行"); &#125;&#125;Thread thread = new Thread(new MyThread1(), "我是杨大哥");thread.run();在自定义的线程中输出了运行这段代码的当前线程名称，并在创建线程时提供了一个自定义线程名称，再次运行这段代码，输出1当前线程：main，实现Runnable接口线程运行还是main线程执行了这段线程执行时代码而已并没有真正的创建一个新的线程，将run方法修改为start方法后，输出1当前线程：我是杨大哥，实现Runnable接口线程运行按照我们预想的线程名称输出了正确的结果Callable接口暂时不举例，会在后续java并发包学习的时候再一并总结如何选择，创建子类还是实现Runnable接口？对于两种方式如何抉择并没有一个标准的答案，只要能够满足需求即可。因为java中有一个线程池的概念，线程池提供了一堆已经创建好的线程，就只差线程运行时代码，如果要使用线程池，更倾向与使用runnable的方式来编写线程运行时代码]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程模型]]></title>
    <url>%2F2021%2F04%2F18%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[我们使用并发系统开处理业务，需要用不同的方式来对业务进行拆分。拆分的方式不同需要考虑的线程之间协作和互斥关系也会不同。分布式系统和并发系模型分布式系统是进程通过网络进行通信完成工作协同；并发系统是线程之间相互通信。进程和线程在操作系统中有很多相似性，所以分布式系统体系结构也可以用在并发系统中。一，并行模型将同一个任务分解为不同的部分执行，完成后进行结果汇总。在java中jdk1.7开始引入的forkjoin框架，hadoop中的mapreduce，都体现了并行思想。执行拆解后的任务可以是不同机器也可以是不同的CPU。优点并行模型很容易理解，容易扩展，将任务拆分后理论上可以增加更多的资源来提升并行度缺点共享状态困难在并行模型中，每个执行任务的工作者可能会共享一些数据，就需要引入一些工作者之间相互通信的机制并且要考虑竟态和死锁问题。此外，在工作者对共享数据访问/操作时，可能会在工作者之间相互等待而丧失一部分并行性。虽然可以通过引入一些非阻塞算法来改善，但是通常情况下非阻塞算法实现起来较为困难。复杂的数据结构也能够解决共享状态带来改观，但往往也不尽人意。比如说一个链表，需要在头部插入一个节点，并且返回指向新加入节点的一个引用，所有其他工作者仍然保持着链表第一个引用无法看到新加入的元素。任务执行顺序不确定多个工作者并行执行任务无法保证各个工作者先后执行完成的顺序。并行模型的这个特性使得并发系统在任何一个时间节点无法推断当前系统的状态二，流水线模型富士康流水线组装手机，每个工人只负责手机的某个部分，一部完整的手机组装完成可能会经过数人操作。每个工人无须知道前一个工人或者后一个工人的工作状态，也可以称作无状态模型。在java中通常使用非阻塞的IO来实现，非阻塞意味着一旦一个工作者在遇到耗时的IO操作的时候不必停顿下来等待而是继续执行其他任务。IO完成的时候工作者可以继续操作将结果交给下一个工作者。有了非阻塞IO模型，可以使用IO操作来确定工作者之间的边界，从而尽可能的利用IO等待时间做更多的事，IO返回结果后，流水线上下一个工作者再继续操作并发系统中流水线可能会有多条，同时执行多个作业，甚至一个工作者可以接收到不同工作者传递的作业。流水线模型优点：工作者之间无须共享状态工作者可以是有状态的可以保证作业顺序性Actors和Channels这两个概念是在java中都有对应的实现。java的NIO中引入channel，每个工作者之间通过channel来进行消息传递，而不用知道是谁传的或者将会传给谁，只需要在在通道上注册自己感兴趣的操作即可，这使得流水线上各个工作者之间松散耦合。使用哪种模型比较好这取决于系统需要干什么，如果业务本身是并行的不需要共享状态，可以使用并行模型比较好。对于很多业务都不是自然独立并行的这种我相信使用流水线模型会发挥系统更大效能]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程优点]]></title>
    <url>%2F2021%2F04%2F10%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E7%82%B9%2F</url>
    <content type="text"><![CDATA[多线程编程尽管对代码编写带来了一定难度，但是得益于现代多核计算机，一定程度上多线程编程也带来了一些优点：提升资源利用率简化的程序设计增加程序响应速度更好的资源利用率我们在系统中有一个文件处理的场景，需要读取两个文件进行处理。我们使用代码进行模拟1234567891011121314long startTime = System.currentTimeMillis();System.out.println("&lt;-------程序开始执行-------&gt;");System.out.println("读取文件A");Thread.sleep(5000);System.out.println("读取文件A完毕");System.out.println("耗时：" + (System.currentTimeMillis()-startTim/1000 + "秒。开始处理文件A");Thread.sleep(2000);System.out.println("处理文件A完毕耗时：" + (System.currentTimeMill()-startTime) + "秒。开始读取文件B")System.out.println("读取文件B");Thread.sleep(5000);System.out.println("读取文件B完毕");System.out.println("耗时：" + (System.currentTimeMillis()-startTim/1000 + "秒。开始处理文件B");Thread.sleep(2000);System.out.println("处理文件B完毕耗时：" + (System.currentTimeMill()-startTime) + "秒。");这段代码使用Thread.sleep来模拟读取和处理文件，sleep的时候当前main线程就会停止请求CPU，待指定时间后才会再次请求使用CPU，如此反复。程序运行结果如下&lt;——-程序开始执行——-&gt;读取文件A读取文件A完毕耗时：5秒。开始处理文件A处理文件A完毕耗时：7002秒。开始读取文件B读取文件B读取文件B完毕耗时：12秒。开始处理文件B处理文件B完毕耗时：14003秒。上面代码并未充分发挥使用CPU，每次读取文件，CPU大多数时间都在等待硬盘IO并未做其他导致了宝贵的CPU资源被浪费。我们可以改进上面的代码来更好的利用CPU，在文件A读取完的时候，然后开始读取文件B，这样CPU可以用等待读取文件B的时间去处理文件A，代码如下123456789101112131415161718192021222324final long start=System.currentTimeMillis();System.out.println("----------程序开始运行---------");System.out.println("读取A文件开始...");Thread.currentThread().sleep(5000);System.out.println("读取A文件结束，耗时："+(System.currentTimeMill()-start)/1000+"秒...开始处理A文件，同时开始读取B文件..");Thread t1=new Thread()&#123; @Override public void run() &#123; try &#123; System.out.println("读取B文件开始..."); Thread.currentThread().sleep(5000); System.out.println("读取B文件结束，耗时："+(SystecurrentTimeMillis()-start)/1000+"秒...开始处理B文件"); Thread.currentThread().sleep(2000); System.out.println("B文件处理完成..."); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;;t1.start();Thread.currentThread().sleep(2000);System.out.println("A文件处理完成...");t1.join();System.out.println("总耗时:"+(System.currentTimeMillis()-start)/10+"秒");改进后的代码读取和操作文件A和B在不同的两个线程中，处理文件A的时候另外一个进程可以同时读取文件B这样使CPU资源利用得到了提升。程序执行结果如下———-程序开始运行———读取A文件开始…读取A文件结束，耗时：5秒…开始处理A文件，同时开始读取B文件..读取B文件开始…A文件处理完成…读取B文件结束，耗时：10秒…开始处理B文件B文件处理完成…总耗时:1200秒总的来说，磁盘IO的速度和CPU速度的远远不匹配的才致使有了优化的空间。当然不止是磁盘IO还有可能是其他相对于CPU的耗时操作，如网络IO，用户输入等程序设计简单如果要在单线程中实现上面优化有的代码，编写代码复杂度肯定要远远大于多线程的编程。单线程中处理多个文件需要代码实现记住每个文件读取的状态和操作，复杂度肯定比多线程要大增加程序响应速度在网络编程BIO中，我们使用一个线程来监听端口并处理响应，典型的伪代码如下123while 服务器未关闭: 监听端口来的请求 处理请求如果某个请求很耗时，那么此期间服务端就不能够接受其他客户端来的请求。一个BIO下替代的方案123while 服务器未关闭: 监听端口请求 提交一个线程来处理该请求无疑这种方式要比第一个方式给客户端带来了更快的响应，这里不做展开意在说明多线程对于程序响应优势。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java并发编程基本知识介绍]]></title>
    <url>%2F2021%2F04%2F05%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[什么是并发？大佬的话作为开篇：两个词很好的说明了并发和并行的区别：Parallel Computing：并行计算Concurrent programming：并发编程例如你打开浏览器，输入你最爱的P站，拿着薯片看两个人打架的视频，同时你还不忘打开QQ看群里大佬们各种吹水，这就是并发。CPU单核与多核早期的dos操作系统只支持单个任务的执行，在同一个时刻只有一个进程运行直到该任务执行完成才能执行下一个任务。这个时期的操作系统都只有一个CPU，但这并不是机器的限制，而是操作系统的限制。之后随着操作系统进化，逐渐开始支持多任务执行，比如，unix，linux和windows。这并不是真正意义上的同时执行，而是单个CPU对于每个任务分配了时间片，只要执行的够快就让我们感觉是同时在执行。单核CPU在同一时间始终只能运行一个进程，只有在CPU多核情况下才能实现真正的并行。如果是2核就能够同时执行2个进程，4核就能够同时执行4个进程进程和线程进程：（英语：process），是指计算机中已运行的程序。进程曾经是分时系统的基本运作单位。在面向进程设计的系统（如早期的UNIX，Linux 2.4及更早的版本）中，进程是程序的基本执行实体；在面向线程设计的系统（如当代多数操作系统、Linux 2.6及更新的版本）中，进程本身不是基本运行单位，而是线程的容器。线程：（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。进程是线程的容器，一个进程至少有一个线程。操作系统为进程运行分配所需要的资源例如内存，存储器，文件和IO设备等。线程共享进程分配的资源，同时也会有自己的私有资源。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3分钟学会mybatis代码生成器使用]]></title>
    <url>%2F2021%2F03%2F28%2F3%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9Amybatis%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用mybatis多少都会涉及到操作数据库的sql配置xml文件，数据库对象的model和mapper文件，如果数据库表比较多手撸起来还是费劲。使用mybatis提供的工具自动生成我们使用mybatis过程中需要手写的mapper和model文件：maven的插件方式一，引入对mybatis-generator-plugin插件1234567891011121314151617181920&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;!-- 输出详细信息 --&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;!-- 覆盖生成文件 --&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator-configuration.xml&lt;/configurationFile&gt; &lt;/configuration&gt;&lt;/plugin&gt;二，编写配置文件generator-configuration.xml，我的如下：12345678910111213141516171819&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;classPathEntry location="数据库驱动包路径"/&gt; &lt;context id="dsql" targetRuntime="MyBatis3DynamicSql"&gt; &lt;jdbcConnection driverClass="数据库驱动包" connectionURL="你的数据库链接信息" userId="数据库用户名" password="数据库密码" /&gt; &lt;javaModelGenerator targetPackage="org.yangxin.demo1.model" targetProject="src/main/java"/&gt; &lt;javaClientGenerator targetPackage="org.yangxin.demo1.mapper" targetProject="src/main/java"/&gt; &lt;table tableName="FM01" /&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt;配置文件的xml可以参考mybatis官网。上面的xml主要配置三个信息：需要连接的数据库的驱动包位置以及对应的链接信息生成mapper和model的包名称数据库表三，运行mybatis-generator-plugin插件：mvn mybatis-generator:generate，运行后会生成对应的mapper和model]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis代码生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一文精通mybatis拦截器]]></title>
    <url>%2F2021%2F03%2F14%2F%E4%B8%80%E6%96%87%E7%B2%BE%E9%80%9Amybatis%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[mybatis插件介绍引用Mybatis官网：MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)ParameterHandler (getParameterObject, setParameters)ResultSetHandler (handleResultSets, handleOutputParameters)StatementHandler (prepare, parameterize, batch, update, query)这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。 如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。 因为在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis 的核心模块。这些都是更底层的类和方法，所以使用插件的时候要特别当心。来看一组例子，通过对Executor接口拦截对query方法输出执行sql的日志信息LogInteceptor实现，继承Inteceptor接口，实现该接口的三个方法：intecept，plugin和setProperties方法。123456789101112131415161718192021222324@Intercepts(&#123;@Signature(type= Executor.class, method = "query", args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)public class LogPlugin implements Interceptor &#123; private final static Logger log = LoggerFactory.getLogger(LogPlugin.class); @Override public Object intercept(Invocation invocation) throws Throwable &#123; Object[] objects = invocation.getArgs(); MappedStatement ms = (MappedStatement)objects[0]; log.debug("执行sql -&gt; " + ms.getBoundSql(null).getSql()); log.debug("参数 -&gt; " + objects[1]); return invocation.proceed(); &#125; @Override public Object plugin(Object target) &#123; return Plugin.wrap(target,this); &#125; @Override public void setProperties(Properties properties) &#123; &#125;&#125;MapperConfig.xml和mapper1.xml配置文件，在config文件中引入自定义的拦截器报名加类型的全路径1234567891011&lt;plugins&gt; &lt;plugin interceptor="org.apache.ibatis.plugin.LogPlugin"&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;mapper namespace="org.yangxin.mapper1"&gt; &lt;select id="getBlog" parameterType="int" resultType="map" &gt; select * from blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;测试代码1234@Testpublic void log_plugin_test()&#123; sqlMapper.openSession().selectList("org.yangxin.mapper1.getBlog", 1);&#125;//执行后console输出DEBUG [main] - Logging initialized using ‘class org.apache.ibatis.logging.slf4j.Slf4jImpl’ adapter.DEBUG [main] - 执行sql -&gt; select * from blog where id = ?DEBUG [main] - 参数 -&gt; 1DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Setting autocommit to false on JDBC Connection [org.apache.derby.impl.jdbc.EmbedConnection@398457879 (XID = 38372), (SESSIONID = 5), (DATABASE = ibderby), (DRDAID = null) ]DEBUG [main] - ==&gt; Preparing: select * from blog where id = ?DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1可以看到加粗部分输入了我们打印的执行sql语句信息源码分析解析xml拦截器123456//1，解析config.xml中的plugins节点pluginElement(root.evalNode("plugins"));//2，将拦截器加入Configuration类configuration.addInterceptor(interceptorInstance);interceptorChain.addInterceptor(interceptor);现在我们通过xml配置的拦截器已经在Mybatis全局配置变量inteceptorChain中了生成拦截对象的代理当我们打开sqlsession的时候，会调用Configuration对象来创建一个具体执行sql的Excecutor类。创建这个类的时候就会生成拦截了Executor接口的代理类12345678910//1，创建Executorfinal Executor executor = configuration.newExecutor(tx, execType);//2，生成代理对象executor = (Executor) interceptorChain.pluginAll(executor);public Object pluginAll(Object target) &#123; for (Interceptor interceptor : interceptors) &#123; target = interceptor.plugin(target);g &#125; return target;&#125;这里最重要的就是mybatis的plugin包下面的Plugin类了，该类有下面两个用途:生成jdk代理并实现了InvocationHandler接口解析实现接口Inteceptor类的注解用于生成代理和拦截对应签名的方法结合源码回过后来再看一下demo发现mybatis拦截器设计很简单和巧妙，也很方便对mybatis各接口功能进行拓展]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis二级缓存入门到精通]]></title>
    <url>%2F2021%2F03%2F06%2Fmybatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%2F</url>
    <content type="text"><![CDATA[一级缓存是session级别的，缓存在一个session内部有效，如果要多个session共享缓存就需要开启二级缓存二级缓存是namespace级别的，不同的namespace不能够共享缓存入门demo开启二级缓存配置123&lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;/settings&gt;开启后executor会以代理模式创建，统一由CachingExecutor代理。mapper代理配置12345&lt;cache eviction="FIFO" size="1024" flushInterval="6000" /&gt;&lt;select id="getBlog" parameterType="string" resultType="map" useCache="true"&gt; select * from blog where id = #&#123;id&#125;&lt;/select&gt;现在来测试一下，两个不同的session是否共享了缓存1234567SqlSession sqlSession1 = ssf.openSession();SqlSession sqlSession2 = ssf.openSession();//两个不同的sessionAssert.assertNotEquals(sqlSession1,sqlSession2);sqlSession1.selectOne("org.yangxin.mapper1.getBlog","1");sqlSession1.commit();sqlSession2.selectOne("org.yangxin.mapper1.getBlog","1");日志输出结果:123456789DEBUG [main] - Cache Hit Ratio [org.yangxin.mapper1]: 0.0DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Setting autocommit to false on JDBC Connection [org.apache.derby.impl.jdbc.EmbedConnection@1530446316 (XID = 37309), (SESSIONID = 5), (DATABASE = ibderby), (DRDAID = null) ]DEBUG [main] - ==&gt; Preparing: select * from blog where id = ? DEBUG [main] - ==&gt; Parameters: 1(String)DEBUG [main] - &lt;== Total: 1DEBUG [main] - Cache Hit Ratio [org.yangxin.mapper1]: 0.5Process finished with exit code 0可以发现session2在并没有查询数据库来获取结果，实际就是访问的缓存。我们也可以配置mapperstatment中的select关闭缓存，只需将useCache改为false，默认为true123&lt;select id="getBlog" parameterType="string" resultType="map" useCache="false"&gt; select * from blog where id = #&#123;id&#125;&lt;/select&gt;运行代码查看控制台输出结果12345678910DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Setting autocommit to false on JDBC Connection [org.apache.derby.impl.jdbc.EmbedConnection@1222768327 (XID = 37411), (SESSIONID = 5), (DATABASE = ibderby), (DRDAID = null) ]DEBUG [main] - ==&gt; Preparing: select * from blog where id = ? DEBUG [main] - ==&gt; Parameters: 1(String)DEBUG [main] - &lt;== Total: 1DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Setting autocommit to false on JDBC Connection [org.apache.derby.impl.jdbc.EmbedConnection@220454978 (XID = 37415), (SESSIONID = 7), (DATABASE = ibderby), (DRDAID = null) ]DEBUG [main] - ==&gt; Preparing: select * from blog where id = ? DEBUG [main] - ==&gt; Parameters: 1(String)DEBUG [main] - &lt;== Total: 1关闭缓存后，我们看到控制台日志输出了两次通过Jdbc连接查询数据。遗留问题，update，delete，commit和rollback对二级缓存有什么影响，通过下面的源码分析我相信可以找到答案源码分析mybatis只有配置了cacheEnabled为true的时候才会生效二级缓存，这样所有的executor才能够被CachingExecutor代理123if (cacheEnabled) &#123; executor = new CachingExecutor(executor);&#125;CachingExecutor代理了所有executor方法，因为在执行各种ddl语句的时候会对二级缓存产生影响，其中主要管理二级缓存的类是TransactionalCacheManager12345678910111213141516171819202122232425262728293031323334353637383940public class TransactionalCacheManager &#123; //管理所有实现的Cache private Map&lt;Cache, TransactionalCache&gt; transactionalCaches = new HashMap&lt;Cache, TransactionalCache&gt;(); public void clear(Cache cache) &#123; getTransactionalCache(cache).clear(); &#125; public Object getObject(Cache cache, CacheKey key) &#123; return getTransactionalCache(cache).getObject(key); &#125; public void putObject(Cache cache, CacheKey key, Object value) &#123; getTransactionalCache(cache).putObject(key, value); &#125; //将本地缓存调用Cache的put方法使缓存生效 public void commit() &#123; for (TransactionalCache txCache : transactionalCaches.values()) &#123; txCache.commit(); &#125; &#125; //将所有未提交的缓存清空，将获取的缓存数据从缓存中移除 public void rollback() &#123; for (TransactionalCache txCache : transactionalCaches.values()) &#123; txCache.rollback(); &#125; &#125; private TransactionalCache getTransactionalCache(Cache cache) &#123; TransactionalCache txCache = transactionalCaches.get(cache); if (txCache == null) &#123; txCache = new TransactionalCache(cache); transactionalCaches.put(cache, txCache); &#125; return txCache; &#125;&#125;TransactionalCache又是代理类，将所实现的cache代理。executor执行影响缓存发放的时候都是由这个类去做相应的实现]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java spi入门及原理分析]]></title>
    <url>%2F2021%2F01%2F12%2Fspi%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[介绍维基百科解释查看wiki。spi全称Service privoder Interface，是java的第三方扩展机制。其中：数据库，jndi，声音服务，文件IO和图片IO都有应用代码demo先从简单的”hello world”开始来直观感受一下spi创建接口和实现该接口123456789101112131415/* * 创建接口 */ public interface IHelloWorld&#123; void say(String name); &#125;/* *实现类 */ public class HelloWorldImpl implements IHelloWorld &#123; @Override public void say(String name) &#123; System.out.println("hello," + name); &#125; &#125;配置文件在resources文件夹下新建META-INF/service，以接口IHelloWorld类全路径未文件命名:文件内容为实现类HelloWorldImpl的全路径名称测试代码123456789@Test//输出 hello worldpublic void spi_test()&#123; ServiceLoader&lt;IHelloWorld&gt; hs = ServiceLoader.load(IHelloWorld.class,Thread.currentThread().getContextClassLoader()); for (IHelloWorld helloWorld : hs) &#123; helloWorld.say("world"); &#125;&#125;原理查看ServiceLoader源码，其中主要有两个问题需要带着去阅读，解决了基本就明白了原理1，为什么要按照META-INI/service，接口文件名和实现类内容创建文件2，如何加载实现类直接上关键代码123456789/* *PREFIX = "META-INF/services/" *这段代码就解释了第一个问题 */String fullName = PREFIX + service.getName();if (loader == null) configs = ClassLoader.getSystemResources(fullName);else configs = loader.getResources(fullName);我在jdk1.8中查看源码，inputstream都实现了AutoCloseable，但是大佬们在解析接口命名的文件的时候没有使用try with resources方式，大佬们也有偷懒的时候啊123456789101112131415try &#123; in = u.openStream(); r = new BufferedReader(new InputStreamReader(in, "utf-8")); int lc = 1; while ((lc = parseLine(service, u, r, lc, names)) &gt;= 0);&#125; catch (IOException x) &#123; fail(service, "Error reading configuration file", x);&#125; finally &#123; try &#123; if (r != null) r.close(); if (in != null) in.close(); &#125; catch (IOException y) &#123; fail(service, "Error closing configuration file", y); &#125;&#125;第二个问题就是大家在熟悉不过的使用Class.forName在加载配置文件中的实现类了12345try &#123; c = Class.forName(cn, false, loader);&#125; catch (ClassNotFoundException x) &#123; fail(service,"Provider " + cn + " not found");&#125;至此spi就算入门了，查看了一下ojdbc.jar包，验证了确实也是以spi的方式提供的，有兴趣的朋友可以再验证一下文章开头所说的服务提供商是否也是spi实现的]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>spi</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis分页原理]]></title>
    <url>%2F2019%2F12%2F21%2Fmybatis%E5%88%86%E9%A1%B5%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[mybatis分页原理在通过session查询数据的时候，根据传入的数据结构RowBounds来进行查询数据库结果集的skip和limit操作达到分页的目的mybatis分页相关代码RowBounds类12345678910111213141516171819202122232425262728public class RowBounds &#123; public static final int NO_ROW_OFFSET = 0;//默认 public static final int NO_ROW_LIMIT = Integer.MAX_VALUE;//默认 public static final RowBounds DEFAULT = new RowBounds();//默认 private int offset; private int limit; public RowBounds() &#123; this.offset = NO_ROW_OFFSET; this.limit = NO_ROW_LIMIT; &#125; public RowBounds(int offset, int limit) &#123; this.offset = offset; this.limit = limit; &#125; public int getOffset() &#123; return offset; &#125; public int getLimit() &#123; return limit; &#125;&#125;可以看出RowBounds类还是比较简单，offset和limit只有这两个成员属性，Mybatis分页主要也是根据这两个属性DefaultSqlSession根据RowBounds类进行分页查询123456789101112131415@Override public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) &#123; return this.selectList(statement, parameter, RowBounds.DEFAULT);&#125;public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123; try &#123; MappedStatement ms = configuration.getMappedStatement(statement); return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException("Error querying database. Cause: " + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125;&#125;如果不传入RowBounds那么使用默认的，offset从0开始，limit为Integer最大值DefaultResultSetHandler根据RowBounds进行返回结果集处理12345678910private void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException &#123; DefaultResultContext&lt;Object&gt; resultContext = new DefaultResultContext&lt;Object&gt;(); skipRows(rsw.getResultSet(), rowBounds);//1 while (shouldProcessMoreRows(resultContext, rowBounds)/*2*/ &amp;&amp; rsw.getResultSet().next()) &#123; ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(rsw.getResultSet(), resultMap, null); Object rowValue = getRowValue(rsw, discriminatedResultMap); storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet()); &#125;&#125;1，根据offset跳过结果集到指定行数2，根据limit获取指定数量的结果集总结mybatis自带分页实现较为简单，将所有结果查询出来，然后取固定某段结果。明显的缺点就是需要将结果全部查询出去，如果进行分页需要手动的去计算指定offset和limit，使用不是很方便。]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis分页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis一级缓存源码分析]]></title>
    <url>%2F2019%2F12%2F14%2Fmybatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[源码分析mybatis的一级缓存是session级别默认开启的，如果使用不当不了解其原理会造成一些隐患。session在执行查询的时候委托给executor，一级缓存为起一个map结构的localCache变量实现。主要代码如下12345678//取缓存数据根据cacheKey，cacheKey数据结构感兴趣可以阅读源码list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;if (list != null) &#123; handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);&#125; else &#123; //没取到就查询数据库 list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);&#125;在queryFormDatabase方法中会put操作localCache将结果缓存。但是如果配置了参数localCacheScop为statement级别那么不会进行缓存1234if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123; // 清空localCache clearLocalCache();&#125;常见问题如果对于同一个命名空间select的id相同，不同session可能会存在脏读1234567891011121314//开启两个session//涉及的测试环境在mybatis源码中可以找到SqlSession session1 = sqlMapper.openSession();SqlSession session2 = sqlMapper.openSession();Blog blog1 = session1.selectOne("org.apache.ibatis.domain.blog.mappers.NestedBlogMapper.selectBlogJoinedWithPostsAndAuthor", 1);Blog blog2 = session2.selectOne("org.apache.ibatis.domain.blog.mappers.NestedBlogMapper.selectBlogJoinedWithPostsAndAuthor", 1);assertEquals("Jim Business", blog1.getTitle());assertEquals("Jim Business", blog2.getTitle());session1.update("org.apache.ibatis.domain.blog.mappers.NestedBlogMapper.upBlogId", 1);session1.commit();Blog blog3 = session1.selectOne("org.apache.ibatis.domain.blog.mappers.NestedBlogMapper.selectBlogJoinedWithPostsAndAuthor", 1);Blog blog4 = session2.selectOne("org.apache.ibatis.domain.blog.mappers.NestedBlogMapper.selectBlogJoinedWithPostsAndAuthor", 1);assertEquals("new title", blog4.getTitle());//失败 falseassertEquals("new title", blog3.getTitle());//成功 true上面代码实际上会测试失败，因为产生了脏读。]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java自动拆装箱问题总结]]></title>
    <url>%2F2019%2F11%2F03%2Fjava%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[java自动拆装箱自jdk1.5以后新增功能。目的是为了解决基础数据类型和对象操作不便利。比如集合List只能操作对象，而无法对基本数据类型进行add，remove等一系列操作。对自动拆装箱学习过程中，产生了一系列疑问，总结如下什么是基础数据类型，什么是包装类jdk如何实现自动拆装箱自动拆装箱优点和缺点自动拆装箱什么时候不自动进行]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java自动拆装箱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Integer的缓存机制]]></title>
    <url>%2F2019%2F11%2F02%2FInteger%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021public class JavaIntegerCache &#123; public static void main(String... strings) &#123; Integer integer1 = 3; Integer integer2 = 3; if (integer1 == integer2) System.out.println("integer1 == integer2"); else System.out.println("integer1 != integer2"); Integer integer3 = 300; Integer integer4 = 300; if (integer3 == integer4) System.out.println("integer3 == integer4"); else System.out.println("integer3 != integer4"); &#125;&#125;由于Integer是对象，两个对象比较，我们普遍的认为上面的两个结果都是false然而结果却会让你大跌眼镜。上面这段代码真正的输出结果：12integer1 == integer2integer3 != integer4原因就在于java5.0以后对于基本类型自动装箱的在范围-127到128之间会进行自动缓存以提升程序性能]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java自动装箱</tag>
        <tag>java缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis动态sql之组合模式]]></title>
    <url>%2F2019%2F11%2F02%2Fmybatis%E5%8A%A8%E6%80%81sql%E5%AE%9E%E7%8E%B0%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[组合设计模式组合设计模式是一种整体与部分的树形层次关系结构。组合对象中各个对象具有相同的行为模式，这样就能处理简单对象一样处理复杂对象。复杂对象的底层细节将会被屏蔽掉，与客户端解耦，最重要的是和简单对象一样实现了同一个接口mybatis动态sql实现同一个接口1234public interface SqlNode &#123; //共同的行为 boolean apply(DynamicContext context);&#125;复杂对象12345678910111213141516 //混合sqlnode节点，组合不同类型的sqlnode //其他node有：trim,set,where,if,otherwise //choose public class MixedSqlNode implements SqlNode &#123; private final List&lt;SqlNode&gt; contents;public MixedSqlNode(List&lt;SqlNode&gt; contents)&#123; this.contents = contents;&#125;@Overridepublic boolean apply(DynamicContext context)&#123; contents.forEach(node -&gt; node.apply(context)); return true;&#125; &#125;简单对象1234567891011121314151617181920212223//if sqlnode实现了接口sqlnode的apply方法，//定义了自己的行为只有当test表达式为真的时候//才会将节点内容增加到动态上下文的sql拼接中public class IfSqlNode implements SqlNode &#123; private final ExpressionEvaluator evaluator; private final String test; private final SqlNode contents; public IfSqlNode(SqlNode contents, String test) &#123; this.test = test; this.contents = contents; this.evaluator = new ExpressionEvaluator(); &#125; @Override public boolean apply(DynamicContext context) &#123; if (evaluator.evaluateBoolean(test, context.getBindings())) &#123; contents.apply(context); return true; &#125; return false; &#125;&#125;mybatis一组复杂sql在xml文件中的配置12345678910111213141516171819202122232425&lt;!-- trim节点作为根节点，下面有三个if子节点，在Mybatis中组织成 一个根节点MixedNode节点下两个trim节点和where节点;trim节点 下一个MixedNode节点，由三个if节点组成;where节点实际上的trim 节点的另一种实现，原理一样 --&gt;&lt;update id="update" parameterType="org.format.dynamicproxy.mybatis.bean.User"&gt; UPDATE users &lt;trim prefix="SET" prefixOverrides=","&gt; &lt;if test="name != null and name != ''"&gt; name = #&#123;name&#125; &lt;/if&gt; &lt;if test="age != null and age != ''"&gt; , age = #&#123;age&#125; &lt;/if&gt; &lt;if test="birthday != null and birthday != ''"&gt; , birthday = #&#123;birthday&#125; &lt;/if&gt; &lt;/trim&gt; &lt;where&gt; 1=1 &lt;if test="id != null"&gt; and id = $&#123;id&#125; &lt;/if&gt; &lt;/where&gt;&lt;/update&gt;总结组合模式对于具有层次关系多个对象能够很好的表达，但是比较抽象不容易掌控。提高了软件设计困难同时屏蔽了对象复杂性，客户端使用变得简单]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis动态sql</tag>
        <tag>组合设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring IoC和容器问题整理]]></title>
    <url>%2F2019%2F10%2F27%2Fspringioc%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是依赖注入以及有什么好处?什么是接口，在java中使用的好处spring bean中为什么推荐使用接口application-context代表什么？你怎么创建一个ApplicationContext实例？描述bean在ApplicationoContext的声明周期最好的关闭ApplicationContext的方式是什么？SpringBoot为我们做了这个吗？能够描述一下下面的问题使用java进行依赖注入使用注解进行依赖注入组件、模块扫描bean的scopebean是懒加载还是预实例化？你怎么控制这种行为？什么是属性源文件？你怎么使用@PropertySource什么是BeanFactoryPostProcessor，有什么用？它什么时候被调用？ProperySourcesPlaceholderConfigurer被用于什么地方？什么是组件扫描？@Autowired注解关于属性、构造器和方法做了什么？如果要向私有属性注入？怎么做到？@Qualifier对@Autowired做了什么补充？什么是对象代理？spring两种创建代理对象的区别？代理对象的限制？代理对象的功能和弊端？@Bean注解有什么用@Bean注解的Bean的默认id是什么？你如果改变？为什么不允许在final类上使用@Configration注解@Configration支持单例bean吗为什么@Bean注解的类的方法也不能是final的什么时候配置profile？在哪些场景会有用@Bean和@Profile能够同时使用吗？@Component和@Profile能够一起使用吗？你能够列举多少种profiles？怎么注入集合和k-v类型的数据到bean中？什么是SpringEL表达式？spring enviroment抽象是什么？$和#有什么区别？]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring IoC</tag>
        <tag>spring容器</tag>
      </tags>
  </entry>
</search>
